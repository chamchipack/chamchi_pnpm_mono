[
  {
    created: 1737976158234,
    updated: 1737976158234,
    category: 'backend',
    imageId: [],
    log: 0,
    markdown_contents:
      '### 가비지 컬렉션이란 무엇인가요?\r\n가비지 컬렉션(GC, Garbage Collection)은 프로그래밍 언어에서 더 이상 사용되지 않는 메모리를 자동으로 회수하는 메커니즘입니다. 이는 개발자가 직접 **메모리를 관리하지 않아도 되도록 도와주며**, 주로 **메모리 누수를 방지**하는 데 중요한 역할을 합니다.\r\n\r\n예를 들어서,\r\n```\r\nconst target = "변수"\r\n```\r\n**target** 이라는 변수가 있습니다. 이 변수가 사용되지도 않는데, 프로그램 내에서 계속 존재한다면 필요없는 메모리를 잡아먹고 있는 식충이가 되겠죠?\r\n\r\n이러한 것들을 개발자가 파악하지 않고도 자동으로 메모리에서 제거해주는 것이 **가비지 컬렉션**이라고 생각하면 됩니다.\r\n\r\n이것을 이해하기 위해서는 **참조 카운트(reference count)** 와 **도달 가능성(reachability)** 개념을 참고하면 좋습니다.\r\n\r\n### 도달 가능성이란?\r\n자바스크립트를 기준으로 **도달 가능한 객체**가 있습니다. 이는 루트와 연결된 모든 객체를 의미해요. 객체, 변수, 함수, 배열이나 DOM 등등이 그 대상이 되는겁니다.\r\n\r\n> 쉽게 말하자면, 이 변수 혹은 객체가 **쓰이는건지 안쓰이는건지를 파악**하기 때문에 도달 가능한지를 알아보는거라고 생각하면 됩니다.\r\n\r\n따라서, **사용되지 않는 변수**가 도달 가능성이 없다고 판단되면, 자바스크립트 엔진이 알아서 가비지 컬렉션으로 메모리를 정리합니다\r\n\r\n### 이벤트 리스너\r\n또한 이벤트 리스너도 그 대상이 됩니다. 그러나 이벤트리스너는 지역변수와는 다르게 해제하지 않으면 메모리에 남아있게 되죠. 근데 리액트를 주로 사용하는 우리는 버튼에 달린 이벤트리스너를 삭제한 적이 없을거에요. 그럼 이것은 어떻게 삭제하고 메모리에서 지워질까요? \r\n\r\n리액트는 이벤트 처리를 위해 DOM 요소에 직접 이벤트 리스너를 등록하지 않습니다. 대신, **합성 이벤트(Synthetic Event)** 라는 시스템을 사용한다고 해요.\r\n\r\n**합성 이벤트(Synthetic Event)란?**\r\n- 리액트는 모든 이벤트를 document 레벨에 단일 이벤트 리스너로 등록합니다.\r\n- 개별 버튼 등 요소에 직접 이벤트 리스너를 붙이지 않고, 이벤트를 한 곳에서 관리합니다.\r\n- 이벤트가 발생하면 리액트는 해당 이벤트를 **합성 이벤트 객체(SyntheticEvent)**로 래핑하여 처리합니다.\r\n\r\n또한 가상돔 + 생명주기의 작동 덕분에, 자동으로 이벤트리스너를 삭제할 수 있다고 해요. 하지만 setInterval과 같은 예외는 주의해야 한다는거.\r\n\r\n### 참조 카운트(Reference Counting)란?\r\n\r\n**참조 카운트(Reference Counting)** 는 메모리 관리 기법 중 하나로, 객체가 몇 번 참조되고 있는지를 기록하여 메모리를 해제할 시점을 결정하는 방법입니다.\r\n\r\n- 기본 원리: 객체가 생성될 때 참조 카운터(Reference Counter)가 1로 설정됩니다. 누군가 그 객체를 참조하면 카운터가 증가하고, 참조가 해제되면 카운터가 감소합니다.\r\n- 가비지 컬렉션 대상: 참조 카운터가 0이 된 객체는 더 이상 사용되지 않는 것으로 간주되어 메모리에서 제거됩니다.\r\n\r\n> 참조 카운트 방식은 추가 연산 비용문제, 효율성 문제등으로 다른 알고리즘으로 대체 되었다고 합니다.\r\n---\r\n## Mark-and-Sweep 알고리즘 \r\n\r\n이 알고리즘을 통해 도달 가능한 객체를 식별하여 제거하는 일을 수행합니다.\r\n\r\n### Mark 단계 (Marking)\r\n**목적**\r\n도달 가능한 객체를 식별하여 "활성(active)" 상태로 표시.\r\n\r\n**과정**\r\n- 루트(Root)에서 시작: 전역 객체(window 또는 globalThis)와 스택에 저장된 모든 변수를 루트로 간주합니다.\r\n- 도달 가능한 객체 추적: 루트 객체에서 참조를 따라가며 연결된 모든 객체를 확인합니다. 객체가 참조하는 다른 객체도 "도달 가능"으로 표시됩니다.\r\n- 활성 표시: 도달 가능한 객체를 "마킹"하여 삭제하지 않도록 합니다.\r\n\r\n### Sweep 단계 (Sweeping)\r\n**목적**\r\n 도달 불가능한 객체를 제거하여 메모리를 해제.\r\n\r\n**과정**\r\n- 도달 불가능한 객체 식별: Mark 단계에서 "활성"으로 표시되지 않은 객체는 "도달 불가능"으로 간주.\r\n- 메모리 해제: 도달 불가능한 객체를 메모리에서 제거.\r\n\r\n> 이 알고리즘도 일시 중단문제 등의 성능 저하문제가 있어서, 이를 대체하는 최적화된 Mark Sweep 알고리즘으로 발전하여 이용되고 있다고 하네요',
    markdown_title: '가비지 컬렉션 ',
    summary:
      '가비지 컬렉션이란 무엇인가요?\r\n가비지 컬렉션(GC, Garbage Collection)은 프로그래밍 언어에서 더 이상 사용되지 않는 메모리를 자동으로 회수하는 메커니즘입니다. 이는...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1737943148397,
    updated: 1737971542035,
    category: '',
    imageId: [],
    log: 0,
    markdown_contents:
      '### 리스트를 캐시에 담아보기\r\n```\r\n const {data, fetchMore, loading} = useQuery(query, {\r\n    variables: {\r\n      input: { ... }\r\n      offset: number\r\n      limit: number,\r\n    },\r\n    fetchPolicy: \'cache-first\',\r\n  });\r\n```\r\n**cache-first 정책**을 이용하여 배열을 가져오는 쿼리를 작성합니다. \r\nfetch는 무한 스크롤로 데이터를 가져올 수 있도록 예시를 구성했고, offset과 limit을 통해 page, perPage를 구성했다.\r\n\r\n위와같이 받은 데이터를, apollo client에서 watchQuery 및 subscribe 하여 캐시에 등록된 데이터를 아래와 같이 확인할 수 있었다\r\n```\r\n{\r\n    "ROOT_MUTATION": {\r\n        "__typename": "Mutation"\r\n    },\r\n    "ROOT_QUERY": {\r\n        "__typename": "Query",\r\n        "getWordListOrType({\\"input\\":{\\"type\\":\\"exampleType\\"},\\"limit\\":10,\\"offset\\":0})": [],\r\n        "getWordListOrType({\\"input\\":{\\"jp\\":\\"\\",\\"kana\\":\\"\\",\\"ko\\":\\"\\",\\"ro\\":\\"\\",\\"type\\":\\"verb\\"},\\"limit\\":8,\\"offset\\":0})": [\r\n            {\r\n                "__ref": "Japanese:678711e95bad51fa0bfadbe0"\r\n            },\r\n            {\r\n                "__ref": "Japanese:678711e95bad51fa0bfadbe3"\r\n            },\r\n            ........\r\n        ]\r\n    },\r\n    "Japanese:678711e95bad51fa0bfadbe0": {\r\n        "__typename": "Japanese",\r\n        "_id": "678711e95bad51fa0bfadbe0",\r\n        "ko": "쓰다",\r\n        "jp": "書く",\r\n        "ro": "kaku",\r\n        "kana": "かく"\r\n    },\r\n    "Japanese:678711e95bad51fa0bfadbe3": {\r\n        "__typename": "Japanese",\r\n        "_id": "678711e95bad51fa0bfadbe3",\r\n        "ko": "보다",\r\n        "jp": "見る",\r\n        "ro": "miru",\r\n        "kana": "みる"\r\n    },\r\n    "Japanese:678711e95bad51fa0bfadbe4": {\r\n        "__typename": "Japanese",\r\n        "_id": "678711e95bad51fa0bfadbe4",\r\n        "ko": "듣다",\r\n        "jp": "聞く",\r\n        "ro": "kiku",\r\n        "kana": "きく"\r\n    },\r\n  .........\r\n}\r\n```\r\n\r\n정규화된 객체 (Japanese:ID)\r\n쿼리 결과에 포함된 데이터를 __typename과 ID(_id)를 조합하여 고유 키로 저장.\r\n리스트는 __ref(참조)를 사용해 이 정규화된 객체를 가리킨다.\r\n\r\n\r\n구현된 UI가 무한스크롤이라서 불러오는 개수만큼 캐시에 담기는것을 확인 할 수 있었다. \r\n\r\n또한 리스트에 있는 **_id를 따라 매핑**을 하기때문에, 서버와의 요청또한 캐시와의 중복된 값들이면 가져오지 않는것을 확인할 수 있었다. GraphQL 서버에서의 콘솔 또한 이전처럼 캐시가 존재할 때는 요청이 들어가지 않았다.\r\n\r\n\r\n### 여기서 문제는\r\n**리스트를 캐시에 담다보면 개수가 엄청 늘어날것같은데, 얼마까지 늘어나는거야**\r\n\r\n라는 궁금증이 있었고, 찾아보니\r\n\r\n캐시가 당연히 메모리를 사용하면서, 캐시에 담긴 데이터가 늘어난다면 **성능 부족**으로 이어질 수 있다는 것이 당연한 의견 이었다.\r\n\r\nLeast Recently Used 정책 이라고 해서 max Size에 도달하면 삭제하는 정책과 같은 것을 직접 추가해야한다는 번거로움이 있긴 하다\r\n\r\n또한 아폴로 클라이언트에서는 자체의 Garbage Collection을 실행할 수 있는 도구가 존재한다. Apollo Client의 캐시에서 참조되지 않는 데이터는 cache.gc() 호출 시 정리된다고 하는데,\r\n\r\n직접 정의하고 세워야하는 번거로움이 있으니 폭 넓은 지식을 통해서 구축해 나가야 하는 필요가 있어보인다. GC에 대해서 좀더 알아 보기로 해야겄어',
    markdown_title: 'GraphQL 캐시 테스트 2',
    summary:
      '리스트를 캐시에 담아보기\r\n\r\ncache-first 정책을 이용하여 배열을 가져오는 쿼리를 작성합니다. \r\nfetch는 무한 스크롤로 데이터를 가져올 수 있도록 예시를 구성했고, off...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1737787061798,
    updated: 1737787061798,
    category: 'react-native',
    imageId: [],
    log: 0,
    markdown_contents:
      "리액트 네이티브는 자바스크립트로 작성된 리액트 컴포넌트를 네이티브(Android, iOS) UI로 변환하여 화면에 표시합니다. 이는 리액트의 Virtual DOM 구조를 기반으로 하며, 자바스크립트와 네이티브 간의 데이터 교환을 가능하게 하는 **Bridge**를 통해 동작합니다. 이번에는 리액트 네이티브의 UI 렌더링 과정을 공부했습니다.\r\n\r\n&nbsp;\r\n\r\n## 1. 리액트 컴포넌트 작성\r\n리액트 네이티브앱 개발은 JSX로 작성된 컴포넌트에서 시작됩니다. 아래와 같은 코드가 있다고 해보죠.\r\n\r\n### 예시\r\n```\r\nfunction App() {\r\n  return (\r\n    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>\r\n      <Text>Hello World</Text>\r\n    </View>\r\n  );\r\n}\r\n```\r\n- `<View>`: 리액트 네이티브의 컨테이너 역할을 하며, 네이티브의 `UIView`(iOS) 또는 `ViewGroup`(Android)에 매핑됩니다.\r\n- `<Text>`: 텍스트를 표시하는 컴포넌트로, 네이티브의 `UILabel`(iOS) 또는 `TextView`(Android)로 변환됩니다.\r\n\r\n---\r\n\r\n&nbsp;\r\n\r\n## 2. Virtual DOM 생성\r\n리액트 네이티브는 JSX를 기반으로 Virtual DOM을 생성한다. 이하는 뭐... 웹개발 할때 많이 봐서 ~~Virtual DOM은 메모리 내의 가상 데이터 구조로, UI의 계층 구조와 속성을 정의합니다. 이는 리액트가 변경 사항을 효율적으로 관리할 수 있게 해줍니다.~~\r\n\r\n---\r\n\r\n&nbsp;\r\n\r\n## 3. Shadow Tree 생성 및 레이아웃 계산\r\n리액트 네이티브는 Virtual DOM을 기반으로 Shadow Tree를 생성한다고 하네요. Shadow Tree는 UI 요소의 레이아웃을 계산하기 위한 데이터 구조입니다.\r\n\r\n### Yoga 레이아웃 엔진\r\n- 리액트 네이티브는 **Yoga 레이아웃 엔진**을 사용해 Flexbox 규칙에 따라 레이아웃을 계산합니다.\r\n- Flexbox는 화면 크기와 방향에 따라 UI 요소를 배치하는 데 사용됩니다.\r\n\r\n### 레이아웃 계산 예\r\n```javascript\r\n<View style={{ flexDirection: 'row', justifyContent: 'space-between' }}>\r\n  <Text>Item 1</Text>\r\n  <Text>Item 2</Text>\r\n</View>\r\n```\r\n- Flexbox 규칙에 따라 `Item 1`과 `Item 2`가 가로 방향으로 배치됩니다.\r\n\r\n---\r\n\r\n## 4. Bridge를 통한 명령 전달\r\n리액트 네이티브는 Shadow Tree에서 계산된 UI 정보와 명령을 JSON 형식으로 직렬화하여 **Bridge**를 통해 네이티브 플랫폼으로 전달합니다.\r\n\r\n### Bridge의 역할\r\n- **JavaScript 스레드**와 **네이티브 스레드** 간의 통신을 담당합니다.\r\n- 비동기 방식으로 동작하여 UI 업데이트와 비즈니스 로직이 독립적으로 수행될 수 있습니다.\r\n\r\n---\r\n\r\n&nbsp;\r\n\r\n## 5. 네이티브 UI 컴포넌트 생성\r\nBridge를 통해 전달된 데이터를 기반으로 네이티브 플랫폼에서 실제 UI 컴포넌트를 생성합니다.\r\n\r\n### 네이티브 매핑 예\r\n- `<View>` → iOS: `UIView`, Android: `ViewGroup`\r\n- `<Text>` → iOS: `UILabel`, Android: `TextView`\r\n- `<Image>` → iOS: `UIImageView`, Android: `ImageView`\r\n\r\n---\r\n\r\n&nbsp;\r\n\r\n## 6. 네이티브 UI 렌더링\r\n각 플랫폼(Android/iOS)에서 생성된 네이티브 UI 컴포넌트는 화면에 표시됩니다.\r\n\r\n- **iOS**: Core Animation Layer를 통해 UI가 렌더링됩니다.\r\n- **Android**: Canvas 및 SurfaceView를 사용해 UI를 그립니다.\r\n\r\n---\r\n\r\n&nbsp;\r\n\r\n## 7. 이벤트 처리\r\n리액트 네이티브 에서의 사용자 입력(버튼 클릭, 스크롤 등) 이벤트는 다음 과정을 통해 처리됩니다:\r\n\r\n- **이벤트 발생**: 사용자가 버튼을 누르거나 화면을 터치.\r\n- **네이티브에서 이벤트 캡처**: 이벤트가 네이티브에서 감지됨.\r\n- **Bridge를 통해 JavaScript로 전달**: 이벤트 정보가 JavaScript로 전달되어 처리됩니다.\r\n- **JavaScript 로직 실행**: 이벤트 핸들러가 실행되어 결과를 처리.\r\n\r\n### 예제\r\n```javascript\r\n<Button title=\"Press Me\" onPress={() => alert('Button pressed!')} />\r\n```\r\n- 버튼 클릭 이벤트는 네이티브에서 감지되고, JavaScript로 전달되어 `alert`가 실행됩니다.\r\n\r\n---\r\n\r\n&nbsp;\r\n\r\n## 렌더링 과정 요약\r\n- **JSX 작성**: UI를 선언적으로 정의합니다.\r\n- **Virtual DOM 생성**: 메모리 내에 UI의 가상 구조를 생성합니다.\r\n- **Shadow Tree 생성 및 레이아웃 계산**: Yoga 엔진을 사용해 레이아웃을 계산합니다.\r\n- **Bridge를 통해 명령 전달**: JavaScript와 네이티브 간 데이터를 교환합니다.\r\n- **네이티브 UI 컴포넌트 생성**: 네이티브 플랫폼의 UI 요소로 변환합니다.\r\n- **UI 렌더링**: 네이티브 화면에 UI를 표시합니다.\r\n- **이벤트 처리**: 사용자 입력을 처리하고 로직을 실행합니다.\r\n\r\n\r\n",
    markdown_title: 'React Native에서 UI가 그려지는 과정',
    summary:
      '리액트 네이티브는 자바스크립트로 작성된 리액트 컴포넌트를 네이티브(Android, iOS) UI로 변환하여 화면에 표시합니다. 이는 리액트의 Virtual DOM 구조를 기반으로 ...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1737774809673,
    updated: 1737774809673,
    category: 'backend',
    imageId: [],
    log: 0,
    markdown_contents:
      '## Fetch Policy\r\n&nbsp;\r\n### cache-first \r\n---\r\n> 캐시에서 데이터를 우선적으로 조회하고, 데이터가 없을 경우에만 네트워크 요청을 보냄.\r\n\r\n- 가장 빠른 응답을 제공.\r\n- 네트워크 요청을 최소화.\r\n- 캐시에 없는 데이터가 필요할 경우 네트워크 요청 발생.\r\n- 자주 변경되지 않는 데이터(예: 사용자 프로필, 설정 정보).\r\n\r\n&nbsp;\r\n### cache-and-network\r\n---\r\n> 캐시에 데이터가 있으면 즉시 반환하고, 동시에 네트워크 요청을 보내 최신 데이터를 가져옴.\r\n네트워크에서 가져온 데이터로 캐시를 업데이트하고 컴포넌트를 재렌더링\r\n\r\n- 사용자 경험(빠른 응답)과 최신 데이터 유지를 동시에 제공.\r\n- 최신 데이터를 항상 유지해야 하는 경우(예: 실시간 데이터 대시보드, 상태 데이터)\r\n\r\n&nbsp;\r\n### cache-only\r\n---\r\n> 캐시에서만 데이터를 조회하고, 데이터가 없으면 에러 발생.\r\n\r\n- 네트워크 요청이 전혀 발생하지 않음.\r\n- 캐시에 없는 데이터를 처리할 수 없음.\r\n- 네트워크 요청을 제한해야 하는 경우.\r\n- 오프라인 상태에서 캐시 데이터만 사용하는 기능.\r\n\r\n&nbsp;\r\n### network-only\r\n---\r\n> 항상 네트워크 요청을 보내고, 캐시를 사용하지 않음.\r\n- 서버에서 최신 데이터를 가져옴.\r\n- 캐시를 무시하므로 데이터 읽기에 더 많은 시간이 소요.\r\n- 항상 최신 데이터를 보장해야 하는 경우(예: 실시간 금융 정보).\r\n\r\n&nbsp;\r\n### no-cache\r\n---\r\n> 네트워크 요청을 보내지만, 응답 데이터를 캐시에 저장하지 않음.\r\n\r\n- 요청은 항상 서버로 가고, 캐시는 사용되지 않음.\r\n- 서버 데이터를 즉시 사용할 수 있지만, 이후 요청에서 캐시를 활용할 수 없음.\r\n- 일회성 요청이나 캐시가 필요 없는 민감한 데이터.\r\n',
    markdown_title: 'GraphQL Cache Options',
    summary: 'Fetch Policy\r\n&nbsp;\r\ncache-first...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1737772405464,
    updated: 1737772960552,
    category: 'backend',
    imageId: [],
    log: 0,
    markdown_contents:
      '### 테스트\r\nGraqhQL이 캐시 데이터를 사용하는 예시를 만들어 보도록 합시다. 간단한 쿼리와 서버로 시각적으로 확인해 봅시다.\r\n\r\n&nbsp;\r\n\r\n**클라이언트**\r\n\r\n아래와 같이 아폴로 클라이언트의 캐시 타입을 정의해 줍니다. 적혀있는대로 _id를 기준으로 캐시를 진행 해봅니다.\r\n```\r\nimport {ApolloClient, InMemoryCache} from \'@apollo/client\';\r\n\r\nconst client = new ApolloClient({\r\n  uri: \'https://나의도메인주소:4000/graphql\',\r\n  cache: new InMemoryCache({\r\n    typePolicies: {\r\n      Word: {\r\n        keyFields: [\'_id\'], // Word 객체는 `_id` 필드를 기반으로 캐싱\r\n      },\r\n    },\r\n  }), // 캐시 설정\r\n  connectToDevTools: true,\r\n});\r\n\r\nexport const GET_ONE_WORD_FROM_ID = (fields: string[] | []) => {\r\n  const defaultFields = [\'_id\', \'ko\', \'jp\', \'ro\'];\r\n  const queryFields = fields && fields.length > 0 ? fields : defaultFields;\r\n\r\n  return gql`\r\n      query GetOneWordFromID($input: ID!) {\r\n         getOneWordFromId(input: $input) {\r\n         __typename\r\n          ${queryFields.join(\'\\n\')}\r\n        }\r\n      }\r\n    `;\r\n};\r\n```\r\n- **__typename**은 GraphQL에서 제공하는 메타필드로, 반환된 데이터가 어떤 타입인지 알려줍니다.\r\n- Apollo Client는 데이터를 캐싱할 때 **__typename + ID를 조합하여 각 객체를 고유하게 식별**한다고 하네요\r\n\r\n&nbsp;\r\n\r\n마찬가지로 클라이언트에서 아래와같이 요청을 보내줍니다. 그러면 서버로 도달하겠죠?\r\n```\r\nexport default function WordFetcher({wordId = \'\', fields = []}) {\r\n  const query = GET_ONE_WORD_FROM_ID(fields);\r\n\r\n  const {loading, error, data} = useQuery(query, {\r\n    variables: {\r\n      input: wordId,\r\n    },\r\n    fetchPolicy: \'cache-first\',\r\n    notifyOnNetworkStatusChange: true, // 네트워크 상태 변화를 감지\r\n  });\r\n```\r\n\r\n**서버의 Resolver**\r\n```\r\nconst getOneWordFromId = async (\r\n  _: undefined,\r\n  {\r\n    input,\r\n  }: {\r\n    input?: ObjectId;\r\n  },\r\n): Promise<Word<TypeGbn>> => {\r\n  console.log(\'요청이 들어왔다.\');\r\n  // 아래로는 Mongodb 요청\r\n```\r\n\r\n서버로 요청을 보내면 리졸버로 콘솔이 찍힐겁니다.\r\n\r\n### 첫 요청시\r\n\r\n![이미지 설명](https://api.chamchipack.com/api/files/6chhfppu6fpcdiq/t2l9eh02itdq0wm/blob_TliNjs7KoG.png)\r\n\r\n\r\n\r\n![이미지 설명](https://api.chamchipack.com/api/files/6chhfppu6fpcdiq/u13hxayl1g9h3q1/blob_H8FR6c9St0.png)\r\n\r\n- 캐시가 없는 상태에서는 당연히 서버로 요청이 들어가겠죠? 정상적으로 요청 콘솔이 찍혔습니다. \r\n\r\n### 두번째 요청\r\n\r\n두번째요청을 진행하면서 아폴로 클라이언트의 모듈을 가지고 캐시가 업데이트 되는지 확인해보았습니다. cache.extract() 에 아래의 콘솔이 찍혔습니다\r\n```\r\nuseEffect(() => {\r\n    const unsubscribe = client\r\n      .watchQuery({\r\n        query: GET_ONE_WORD_FROM_ID([]),\r\n        variables: {input: \'678711e95bad51fa0bfadbe4\'},\r\n      })\r\n      .subscribe(() => {\r\n        console.log(\'업데이트된 캐시:\', client.cache.extract());\r\n      });\r\n\r\n    return () => unsubscribe.unsubscribe();\r\n  }, [client]);\r\n\r\n// subscribe의 콘솔\r\n"Japanese:678711e95bad51fa0bfadbe4": {\r\n    "__typename": "Japanese",\r\n    "_id": "678711e95bad51fa0bfadbe4",\r\n    "ko": "듣다",\r\n    "jp": "聞く",\r\n    "ro": "kiku"\r\n}\r\n"ROOT_QUERY": {\r\n    "__typename": "Query",\r\n    "getOneWordFromId({\\"input\\":\\"678711e95bad51fa0bfadbe4\\"})": {\r\n        "__ref": "Japanese:678711e95bad51fa0bfadbe4"\r\n    }\r\n}\r\n```\r\n\r\n당연하게도 서버에는 콘솔이 찍히지 않았습니다. 즉 서버로 요청이 들어가지 않았단 뜻 이겠죠. \r\n\r\n## 생각\r\n서버로 요청이 들어가지 않았던 것에 감탄했다\r\n> 물론 경우에 따라서 캐시의 활용방안이 달라지겠지만, 서버와 통신을 줄일 수 있다는 점에 대해서는 굉장히 긍정적인 생각을 가지게 되었습니다.\r\n\r\n- 물론 한개의 아이디를 가지고서 테스트를 진행했기 때문에, 다량의 리스트를 출력한다거나, 기타 이외의 경우를 생각했을때, 과연 어떻게 동작 할 지에 대한 테스트는 직접 겪어봐야겠지만\r\n- **중복된 형태의 데이터**를 지속적으로 요청 한다고 가정했을때, 캐시의 활용도는 그 가치가 높다라고 생각 됩니다. ',
    markdown_title: 'GraphQL 캐시 테스트',
    summary:
      '테스트\r\nGraqhQL이 캐시 데이터를 사용하는 예시를 만들어 보도록 합시다. 간단한 쿼리와 서버로 시각적으로 확인해 봅시다.\r\n\r\n&nbsp;\r\n\r\n클라이언트\r\n\r\n아래와 같이 아폴로 클라이...',
    tag: [],
    theme: 'study',
    thumbnail:
      'https://api.chamchipack.com/api/files/6chhfppu6fpcdiq/t2l9eh02itdq0wm/blob_TliNjs7KoG.png',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1737707966286,
    updated: 1737879255966,
    category: 'backend',
    imageId: [],
    log: 0,
    markdown_contents:
      '기본적으로 HTTP 캐시 저장과는 다른 방식으로 운영되기 때문에, 만약 중복 쿼리에 대한 요청이 자주 일어난다면 서버에 대한 요청을 줄이고 캐시를 활용하는 전략을 취해야 할 것이다.\r\n\r\n&nbsp;\r\n\r\n### 예시\r\n```\r\ntype Person {\r\n  id: ID!\r\n  name: String!\r\n  age: Int!\r\n  location: Location # Person과 연결된 Location\r\n}\r\n\r\ntype Location {\r\n  id: ID!\r\n  city: String!\r\n  country: String!\r\n}\r\n```\r\n\r\n위와같은 스키마를 가진 모양이 있다고 가정 해봅시다. 중첩이 된 스키마에서 요청시에는 어떻게 캐시 저장이 될까요?\r\n\r\n1차적으로 아마도 아래와 같은 쿼리를 보내어 데이터를 가져오게 될 겁니다.\r\n\r\n```\r\nquery GetPerson {\r\n  person(id: "1") {\r\n    __typename // \r\n    id\r\n    name\r\n    age\r\n    location {\r\n       __typename\r\n      id\r\n      city\r\n      country\r\n    }\r\n  }\r\n}\r\n```\r\n\r\n__typename은 GraphQL 서버가 자동으로 제공하는 내장 메타필드이다. 두개의 스키마를 구분할 수 있는 도구라고 생각을 해보면 편할 것 같습니다. 당연히 person과 location은 다른 스키마 이기 때문에 서로 구분이 달라야 하겠죠.\r\n\r\n### 이때\r\n\r\nGraphQL 캐시는 위와같은 요청을 받을때 이렇게 동작한다고 합니다.\r\n\r\n- 평면화 (FLAT) : 여러개의 스키마를 평면화 시킨다.\r\n- 평면화를 한 다음 캐시에 저장하기\r\n\r\n\r\n즉 아래와 같이 캐시에 저장하여, 만약 각각 같은 요청이 반복적으로 들어오면 **각각 캐시 처리를 할 수 있게 하게 됩니다.**\r\n```\r\n{\r\n  "Person:1": {\r\n    "__typename": "Person",\r\n    "id": "1",\r\n    "name": "John Doe",\r\n    "age": 30,\r\n    "location": {\r\n      "__ref": "Location:101"\r\n    }\r\n  },\r\n  "Location:101": {\r\n    "__typename": "Location",\r\n    "id": "101",\r\n    "city": "Seoul",\r\n    "country": "South Korea"\r\n  }\r\n}\r\n```\r\n\r\n> 2개 이상의 스키마를 요청하면, 정규화를 진행해서 캐시에 각각 평면으로 저장을 한 다음, 각각요청이 캐시에 있는것과 \r\n동일할경우, 이미 캐시에 저장된 데이터를 불러올 수 있게 한다는 것\r\n\r\n실제 이런 캐시 저장은 클라이언트에서 캐시에 대한 정의가 필요한 점을 생각해야한다.\r\n\r\n```\r\nimport { ApolloClient, InMemoryCache } from "@apollo/client";\r\n\r\nconst client = new ApolloClient({\r\n  uri: "https://example.com/graphql", // GraphQL 서버 주소\r\n  cache: new InMemoryCache({\r\n    typePolicies: {\r\n      Person: {\r\n        keyFields: ["id"], // Person의 캐시 키는 id로 식별\r\n      },\r\n      Location: {\r\n        keyFields: ["id"], // Location의 캐시 키도 id로 식별\r\n      },\r\n    },\r\n  }),\r\n});\r\n```\r\n\r\n그렇게 되면 아래와같이 서버까지 요청이 가지 않고, 중간에 캐시에서 동일한 데이터를 가져오게 한다.\r\n\r\n출처 : https://www.apollographql.com/docs/react/caching/overview\r\n\r\n&nbsp;\r\n\r\n\r\n\r\n![이미지 설명](https://api.chamchipack.com/api/files/6chhfppu6fpcdiq/wcv3sm4lao42a1p/blob_VCw4lfDONk.png)',
    markdown_title: 'GraphQL Cache [캐시]',
    summary:
      '기본적으로 HTTP 캐시 저장과는 다른 방식으로 운영되기 때문에, 만약 중복 쿼리에 대한 요청이 자주 일어난다면 서버에 대한 요청을 줄이고 캐시를 활용하는 전략을 취해야 할 것이다...',
    tag: [],
    theme: 'study',
    thumbnail:
      'https://api.chamchipack.com/api/files/6chhfppu6fpcdiq/wcv3sm4lao42a1p/blob_VCw4lfDONk.png',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1737697481726,
    updated: 1737705098648,
    category: 'backend',
    imageId: [],
    log: 0,
    markdown_contents:
      '## 개념\r\nREST API의 한계를 극복하기 위해 설계된 효율적인 데이터 교환 방식\r\n\r\n&nbsp;\r\n### 무엇이 효율적이죠?\r\n- REST API의 정적인 엔드포인트 및 리턴값 고정화에 따른 불편함\r\n- 오버페칭의 문제 \r\n\r\n이와같은 문제들을 극복하기 위한 쿼리형 요청 설계\r\n\r\n> JSON 필드가 30개 인것과 10개인것을 불러온다고 가정한다면, 다양한 자료형의 길이에 따라 다르겠지만, 1KB 정도의 크기 차이를 보이지 않을까?\r\n**데이터의 규모가 클 때** 오버페칭을 상쇄하는 효과가 더 클 것이다.\r\n\r\n물론 클라이언트가 많은 상황에서 오버페칭을 한다면 크기의 수가 기하급수적으로 늘어날 것이다.\r\n\r\n\r\n&nbsp;\r\n### 특징\r\n- **쿼리** : REST의 GET의 기능을 주로 함\r\n- **Mutation** : POST PUT 등의 수정 요청을 주로 함\r\n- **Subscription** : 웹소켓 기능 사용 가능\r\n\r\n&nbsp;\r\n\r\n### 협업에 대해서\r\n백엔드와 프론트엔드간 개발 중 가장 난이도가 높은것은 **기술에 대한 부분이 아니었다**. (이건 주관적 견해) 가장 어려운 것은 소통이었다.\r\n\r\nAPI 사용을 위한 문서가 정리 되어있긴 하지만, 각 엔드포인트가 무엇을 의미하는지, 이런 정보는 어디서 가져오는지, 저런 데이터는 어디서 가져오는지 파악하는데 시간이 생각보다 오래 걸린다.\r\n\r\n물론 REST API 자체가 문제라기보다는, 내 머리가 문제였을 가능성이 높지만, GraphQL을 사용하며 느낀점이 명확했다.\r\n\r\n&nbsp;\r\n\r\n### 마치 타입스크립트를 처음 써봤을때 같달까\r\n--- \r\n타입스크립트를 처음 사용했을때는, 이 **복잡하고 어려운걸** 왜 쓰나 싶었다. 하지만 복잡한 타입스크립트놈은 **네가 무슨 파라미터를 넣어야 하는지**를 명확하게 알려주기 때문에, 공식을 그대로 따라가게 유도하는 좋은 효과가 있었다.\r\n\r\n&nbsp;\r\n\r\n그렇다. 그런 느낌이다.\r\n\r\n&nbsp;\r\n\r\n### 불필요한 소통 제거\r\n---\r\n프로젝트를 시작하면 기능정의나 기획단계에서부터 API에서는 심오한 작업에 들어간다. \r\n\r\n바빠죽겠는데 API 사용에 대해 불필요한 소통을 하는 경우가 있다.\r\n\r\n쿼리형으로 작업하면, 마치 타입스크립트를 보듯이, 클라이언트에서 **"아 이렇게 요청하고... 테스트 해볼까?"**\r\n\r\n```\r\n// Client 에서 이렇게 요청하면 테스트가 된다. 그걸 그대로 프론트로 \r\n가져가면 된다.\r\n\r\nquery {\r\n    getUser(input: {...}) {\r\n        ....\r\n    }\r\n}\r\n```\r\n그러면 테스트가 끝난다. 당연히 스키마를 구성하는데에 많은 소통이 필요하겠지만, 어차피 해야할 소통이라면 처음에 명확하고 깊게 하면 되지 않을까요?\r\n\r\n**문서화도 자동**으로 되기 때문에 불필요한 소통이 너무나도 줄여지는 것이 사실이다.\r\n\r\n',
    markdown_title: 'GraphQL?',
    summary:
      '개념\r\nREST API의 한계를 극복하기 위해 설계된 효율적인 데이터 교환 방식\r\n\r\n&nbsp;\r\n무엇이 효율적이죠?\r\nREST API의 정적인 엔드포인트 및 리턴값 고정화에 따른 불편함...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1737200277924,
    updated: 1737775270062,
    category: 'react-native',
    imageId: [],
    log: 0,
    markdown_contents:
      '## 카카오\r\n\r\n### Delegate.m 설정\r\n\r\nAppDelegate 파일에서 Kakao Login을 처리하기 위해 openURL 메서드에 Kakao 관련 처리를 추가해야 합니다. Kakao Login SDK에서 제공하는 메서드를 활용하여 로그인 URL을 처리합니다:\r\n\r\n```\r\n#import <RNKakaoLogins.h>\r\n// kakao\r\n\r\n\r\n@implementation AppDelegate\r\n\r\n- (BOOL)application:(UIApplication *)app\r\n     openURL:(NSURL *)url\r\n     options:(NSDictionary<UIApplicationOpenURLOptionsKey,id> *)options {\r\n if([RNKakaoLogins isKakaoTalkLoginUrl:url]) {\r\n    return [RNKakaoLogins handleOpenUrl: url];\r\n }\r\n return NO;\r\n}\r\n```\r\n\r\n위 코드는 Kakao SDK에서 제공하는 URL 처리를 AppDelegate에 추가하여 Kakao Login 요청을 처리하도록 설정합니다.\r\n\r\n### Info.plist\r\n```\r\n<key>KAKAO_APP_KEY</key>\r\n<string>{keykeykeykey}</string>\r\n<key>LSApplicationQueriesSchemes</key>\r\n<array>\r\n<string>kakao{keykeykeykey}</string>\r\n<string>kakaolink</string>\r\n<string>kakaokompassauth</string>\r\n</array>\r\n```\r\n\r\n- KAKAO_APP_KEY: Kakao Developers에서 발급받은 앱 키.\r\n\r\n- LSApplicationQueriesSchemes: Kakao SDK에서 사용하는 URL 스킴을 명시하여 iOS 앱의 보안 설정과 통신 가능성을 보장.\r\n\r\n### 토큰 흐름\r\n\r\n액세스와 리프레시를 카카오로부터 받고 액세스는 키체인으로, 리프레시는 서버에 둔다. 로그인 후 서비스를 이용한다\r\n\r\n근데 액세스토큰으로 서비스에서 뭔가 할 일이 있을까? 사실상의 유저 편의성을 위한 로그인 서비스 측면성이 강한데.\r\n\r\n&nbsp;\r\n\r\n리프레시도 2개월마다 갱신이 필요한데, (물론 서버에서 해버리면 되지만) 굳이 그렇게 해야 할 필요가 있을까? 토큰으로 통신을 하는것도 아닌데? 서비스 제작자의 의도에 따라 다른걸까?\r\n\r\n&nbsp;\r\n\r\n### 서비스 제작자의 의도에 따른 설계 방향\r\n\r\n카카오 로그인과 토큰 관리는 서비스 설계 의도에 따라 달라질 수 있을건데\r\n\r\n- 단순 인증용: 사용자 로그인 상태만 유지한다면, 액세스 토큰만으로 충분하며, 리프레시 토큰 관리 필요성이 낮아질 수 있다.\r\n\r\n- 카카오 API 적극 활용: 사용자 프로필 조회, 소셜 기능, 메시지 전송 등 카카오의 다양한 기능을 활용한다면 액세스 토큰과 리프레시 토큰의 철저한 관리가 필수적일것이다.',
    markdown_title: '소셜로그인 참고점',
    summary:
      '카카오\r\n\r\nDelegate.m 설정\r\n\r\nAppDelegate 파일에서 Kakao Login을 처리하기 위해 openURL 메서드에 Kakao 관련 처리를 추가해야 합니다. Kakao ...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1737019469444,
    updated: 1737705063467,
    category: 'react-native',
    imageId: [],
    log: 0,
    markdown_contents:
      '### 개념\r\n\r\n네이티브에서 사용되는 **JavaScript 번들러**\r\n\r\n네이티브 앱을 실행하거나 빌드할 때 JavaScript 코드를 효율적으로 처리하고 네이티브 코드와 통합하는 역할\r\n\r\n&nbsp;\r\n\r\n### Role\r\n- 모듈 번들링: 네이티브 프로젝트의 모든 JavaScript 파일과 모듈을 분석하고 **하나의 번들 파일로 결합** 및\r\nES6, CommonJS와 같은 다양한 모듈 시스템을 지원.\r\n\r\n- 빠른 빌드 속도: 파일 변경 사항만 감지하여 **수정된 부분만 다시 번들링하는 파일 캐싱을 지원**\r\n\r\n- 핫 모듈 리플레이스먼트(HMR): 코드 수정 후 앱을 새로고침하지 않고도 변경 사항을 즉시 반영\r\n\r\n- 소스맵 생성: 번들 파일에서 원래의 소스 코드와 디버깅 가능한 매핑을 제공 디버깅 시 원래의 JavaScript 코드로 문제를 추적할 수 있게 함\r\n\r\n- 네이티브 모듈 통합: \b네이티브가 네이티브(Android/iOS) 코드와 JavaScript 사이에서 상호작용할 수 있도록 지원\r\n\r\n&nbsp;\r\n\r\n### 원리\r\n\r\n- 입력 파일 분석: 프로젝트의 엔트리 파일에서 시작하여 애플리케이션에서 사용되는 모든 JavaScript 파일을 재귀적으로 탐색\r\n\r\n- Dependency Graph 생성: 프로젝트에서 사용하는 모든 모듈과 파일의 의존성 그래프를 생성, 이 그래프를 바탕으로 필요한 모든 코드를 포함하여 최적화된 번들 파일을 생성함\r\n\r\n- 파일 변경 감지: 파일 시스템 감시 기능을 통해 JavaScript 파일의 변경 사항을 실시간으로 감지한다. 변경된 파일만 다시 번들링하여 빠른 업데이트를 제공합니다.\r\n\r\n\r\n&nbsp;\r\n\r\n**그래서**\r\n> JavaScript 코드가 네이티브 환경에서 실행되도록 가교 역할을 함.\r\n\r\n### 컨피그상 주요 도구\r\n\r\n**watchFolders**\r\n> Metro가 감시해야 할 추가 디렉토리를 설정\r\n\r\n**blacklistRE**\r\n> 번들링 제외하는 폴더\r\n',
    markdown_title: '메트로 Metro',
    summary:
      '개념\r\n\r\n네이티브에서 사용되는 JavaScript 번들러\r\n\r\n네이티브 앱을 실행하거나 빌드할 때 JavaScript 코드를 효율적으로 처리하고 네이티브 코드와 통합하는 역할\r\n\r\n&nbs...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1736943865946,
    updated: 1736943865946,
    category: 'react-native',
    imageId: [],
    log: 0,
    markdown_contents:
      '### 개념\r\nReact Native에서 제공하는 (key-value) 기반의 **비동기 데이터 저장소** \r\n\r\n애플리케이션 내에서 로컬 데이터를 저장하고 관리할 수 있도록 설계됨. 이를 통해 간단한 설정값, 사용자 세션, 인증 토큰 등의 데이터를 저장가능\r\n\r\n&nbsp;\r\n\r\n### 데이터 저장 위치\r\n\r\n- iOS: 데이터는 앱의 **Library/Application Support** 디렉토리에 저장된다. 내부적으로 RCTAsyncLocalStorage_V1 라는 디렉토리를 사용하며, 이는 앱별로 격리되어 있음. (manifest.json에 key value로 기록)\r\n- Android: 데이터는 내부 스토리지의 SharedPreferences 또는 SQLite 데이터베이스에 저장.\r\n\r\n> **Library/Application Support**\r\n 설정, 캐시, 데이터베이스, 로그 파일 등이 저장\r\n\r\n&nbsp;\r\n\r\n> **비동기로 저장한다**\r\n&nbsp;\r\n데이터를 저장하거나 읽는 작업이 애플리케이션의 **주 실행 흐름(main thread)**을 차단하지 않고, 백그라운드에서 처리된다는 것을 의미. 이를 통해\b성능유지 및 개선 가능\r\n\r\n---\r\n\r\n### Key Chain\r\nKeychain은 React Native에서 **민감한 데이터(예: 인증 토큰, 비밀번호)** 를 안전하게 저장하기 위해 사용되는 라이브러리. iOS와 Android 모두에서 네이티브 보안 저장소를 사용하여 데이터를 암호화하고 저장.\r\n\r\n&nbsp;\r\n\r\n### Keychain의 작동 원리\r\n- iOS: iOS의 Keychain Services API를 사용해 데이터를 저장.\r\n**데이터는 디바이스에 종속**되어 있으며, AES-256 암호화를 사용해 보호.\r\n키체인에 저장된 데이터는 앱이 삭제되지 않는 한 보존되며, 사용자 인증(예: Face ID, Touch ID)을 통해 접근가능.\r\n\r\n- Android: Android의 Keystore System을 사용해 데이터를 저장함.\r\n데이터를 저장하기 전에 AES 키를 생성하고, 이를 디바이스 보안 하드웨어(하드웨어 보안 모듈, HSM)에서 관리.\r\n데이터는 RSA 또는 AES를 사용해 암호화된다.\r\n\r\n### 데이터 저장 위치\r\n- iOS: Keychain Services를 통해 데이터를 저장한다. 데이터는 디바이스의 **보안 영역(Secure Enclave)** 에 저장된다.\r\n앱 간에 데이터를 공유하려면 Keychain Access Groups를 설정해야\u001f.\r\n\r\n- Android: Android의 Keystore System을 사용\u001f. 데이터는 디바이스의 Tee(Trusted Execution Environment) 또는 Strongbox에 저장\r\n',
    markdown_title: 'AsyncStorage & KeyChain',
    summary:
      '개념\r\nReact Native에서 제공하는 (key-value) 기반의 비동기 데이터 저장소 \r\n\r\n애플리케이션 내에서 로컬 데이터를 저장하고 관리할 수 있도록 설계됨. 이를 통해 간단...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1736666266804,
    updated: 1738307414836,
    category: '',
    imageId: [],
    log: 0,
    markdown_contents:
      '### 공부할거 정리하기\r\n - ~~graphq~~\r\n> update | delete\r\n\r\n- ~~AsyncStorage~~\r\n- react-native-keychain\r\n\r\n```\r\n1. App.tsx\r\nstorage 혹은 keychain에 담긴 정보 Load\r\nrecoil에 전역 상태관리\r\nrecoil 컴포넌트 분기처리\r\n\r\n```\r\n\r\n- ~~마이페이지~~\r\n- ~~어플 graphql~~\r\n- ~~소셜 로그인을 통한 storage 및 session 관리~~\r\n- https://it-amin.tistory.com/131\r\n- ~~mongo 컬렉션 등록~~\r\n- ~~graphql api 등록~~\r\n- ~~클라이언트 mutation 등록~~\r\n- ~~keyChain 등록~~\r\n- ~~단어 디테일 페이지 수정~~\r\n- ~~인풋창 수정~~\r\n- ~~에디터창 수정~~\r\n- ~~로그아웃 세션관리~~\r\n- ~~스플래시 요청시 토큰 리프레시~~\r\n- blog api graphql 상세페이지 : 캐시 + subscribe + 캐시 삭제 등\r\n- 블로그 container 너비\r\n- timestamp\r\n- modal wrapper borderradius\r\n- chip\r\n- serverside \r\n\r\n---\r\n- ~~api~~\r\n- dummy set 넣기\r\n- thumbnail 및 사진 구조 파악',
    markdown_title: '할거정리',
    summary: '공부할거 정리하기\r\ngraphq',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1736245509073,
    updated: 1736943043157,
    category: '',
    imageId: [],
    log: 0,
    markdown_contents:
      '전 직장 동료 및 공부를 함께 한 동료와 오랜만에 만나 대화를 하던 중, 본인 사업을 같이 하자는 의뢰를 받았다.\r\n\r\n아직 확실하게 관계가 정리된 건 아니지만, 일단 어느 정도 손발을 맞춰가자는 의도가 상호 간에 전달이 되었고, 직장을 그만 둔 나에게 새로운 기회가 찾아온 듯 하다.\r\n\r\n알고 지낸지는 3년이 넘어가는 것 같은데, 사람 인연이라는게 참 어떻게 될 지 모르는게 신기하다. \r\n\r\n&nbsp;\r\n\r\n### 개발도구\r\n어플개발로써, React-Native를 사용하게 될 것이다. 나는 플러터만 조금 해본 웹 개발자였으나, 리액트 네이티브는 진입장벽이 훨씬 괜찮을 것으로 판단이 되었다. \r\n\r\n&nbsp;\r\n\r\n**2024. 12. 31**\r\n\r\n오랜만에 만나서 처음 대화가 이루어진 날\r\n\r\n- 먼저 네이티브에 익숙해지기 위해서 실행해보고 퍼블리싱을 시작해보기로 했음\r\n\r\n&nbsp;\r\n\r\n**2025. 01. 01**\r\n\r\n- 기존에 있던 xCode를 이용해 ios 환경을 구축하여 리액트 네이티브를 시작했다.\r\n\r\n&nbsp;\r\n\r\n**2024. 01. 04**\r\n\r\n알고 지내던 기획 & 디자이너 2명에게 간단한 어플 페이지 1개를 의뢰드렸다. 아직 기획이 작성중인 단계에서 부탁드리기 미안했으나, 그동안의 쌓인 신뢰로 흔쾌하게 수락해주었고, 1주일정도 걸릴 것 같다는 이야기를 듣게 되었다.\r\n\r\n&nbsp;\r\n\r\n**2024 .01 .07**\r\n\r\n안드로이드 환경을 구축했다. 아이폰은 있는데, 안드로이드 스마트폰이 없어서 일단은 에뮬레이터를 이용하여 개발을 해야할 것 같다.\r\n\r\n- 안드로이드 스튜디오 & 에뮬레이터를 이용한 개발 시작\r\n\r\n&nbsp;\r\n\r\n**2024 .01 .08**\r\n\r\n- PG와 아임포트에서 운영하는 결제모듈을 이용하여 테스트\r\n- 나는 개인사업자가 아니기 때문에, 테스트로 데이터를 주고 받고 처리를 진행함. \r\n- 생각보다 간단하게 이용할 수 있도록 구성되어 있어서 테스트가 용이함\r\n\r\n&nbsp;\r\n\r\n**2024 .01 .09**\r\n\r\n- 카메라와 갤러리 접근 방식에 대해 공부\r\n- 권한 설정 및 허가에 대한 각 OS의 접근 방식에 대해 공부\r\n- 런타임 권한은 앱 실행 중(런타임)에 사용자로부터 동의를 받아야만 사용할 수 있는 민감한 권한\r\n- 이 외에도 사용자의 허가 없이 사용 가능한 권한 (네트워크 확인 등)등에 대한 정보를 확인중 \r\n\r\n&nbsp;\r\n\r\n**2024 .01 .12**\r\n- graphql + express로 API 해보는 중\r\n- 재미있다.\r\n\r\n\r\n&nbsp;\r\n\r\n**2024 .01 .14**\r\n\r\n- 기획 & 디자이너와의 온라인 미팅\r\n- 팀원으로 합류가능한지 요청 드림 고민 및 심사숙고중\r\n\r\n&nbsp;\r\n\r\n**2024 .01 .15**\r\n\r\n- AsyncStorage에 대한 공부\r\n- 받은 디자인으로 UI 새로 짜보는 중\r\n',
    markdown_title: '개발일지 1',
    summary:
      '전 직장 동료 및 공부를 함께 한 동료와 오랜만에 만나 대화를 하던 중, 본인 사업을 같이 하자는 의뢰를 받았다.\r\n\r\n아직 확실하게 관계가 정리된 건 아니지만, 일단 어느 정도 손발...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1735722678050,
    updated: 1736427064398,
    category: 'react-native',
    imageId: [],
    log: 0,
    markdown_contents:
      '### 아이콘 사용법\r\n---\r\n**IOS**\r\n- react-native-vector-icons 라이브러리 (+types) 설치가 필요\r\n- https://shiro21.tistory.com/475 감사 ㅠㅠ\r\n\r\nxCode로 열고, node_modules의 Fonts 디렉토리를 복사해서 넣어줘야 함.\r\n\r\n**안드로이드**\r\n\r\n\r\n```\r\n// android/app/bundle.gradle \r\napply from: "../../node_modules/react-native-vector-icons/fonts.gradle"\r\n\r\n이 구문을 넣어서 바라보게 해주면 작동합니다.\r\n```\r\n\r\n\r\n&nbsp;\r\n\r\n**폰트의 이름 목록**\r\n\r\nhttps://oblador.github.io/react-native-vector-icons/\r\n\r\n&nbsp;\r\n### ios 스플래시 이미지\r\n---\r\n**react-native-splash-screen** 라는 라이브러리를 사용해본다.\r\n\r\n\r\n```\r\nimport SplashScreen from \'react-native-splash-screen\';\r\n\r\nuseEffect(() => {\r\n    setTimeout(() => {\r\n      SplashScreen.hide();\r\n    }, 1500); //스플래시 활성화 시간\r\n  }, []);\r\n```\r\n\r\n먼저, App.tsx 에서 이러한 선언을 해놓고 **xcode**에서 추가적인 설정이 필요하다.\r\n\r\n- 이미지를 넣으려면 xcode에서 workspace를 열고 **[project]/[project]/images** 경로를 찾아간다\r\n\r\n- 좌측 하단 중단부의 Image Set을 만들어 이미지를 삽입후\r\n- 같은 경로의 LaunchScreen 에서 ViewController 및 우측 상단의 + 버튼으로 **Image View**를 찾아서 이미지를 끌어다 삽입한다.\r\n\r\ndeletegate.m 파일에서 아래와같은 수정이 이루어지면 된다. \r\n```\r\n....\r\n#import "RNSplashScreen.h"\r\n\r\n...\r\n- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions\r\n{\r\n ...\r\n  self.initialProps = @{};\r\n\r\n  [super application:application didFinishLaunchingWithOptions:launchOptions];\r\n  [RNSplashScree~~n ~~~~~~~~~~show]; //여기랑\r\n  \r\n  return YES; // 여기\r\n}\r\n```\r\n &nbsp;\r\n### 네이버지도\r\n---\r\n라이브러리 준비함.\r\n>  @mj-studio/react-native-naver-map\r\n\r\n\r\n- IOS\r\n\r\n```\r\n// Info.plist\r\n\r\n<dict>\r\n <key>NMFClientId</key>\r\n <string>네이버 클라우드에서 받은 클라이언트 키</string>\r\n <key>NSLocationAlwaysAndWhenInUseUsageDescription</key>\r\n <string>{{usage description}}</string>\r\n <key>NSLocationTemporaryUsageDescriptionDictionary</key>\r\n <dict>\r\n    <key>{{your purpose key}}</key>\r\n    <string>{{usage description}}</string>\r\n </dict>\r\n <key>NSLocationWhenInUseUsageDescription</key>\r\n <string>{{usage description}}</string>\r\n```\r\n\r\n- Android\r\n\r\n```\r\n// android/bundle.gradle\r\nmaven { url \'https://repository.map.naver.com/archive/maven\' }\r\n\r\n// SDK 3버전을 사용할 수 있도록 하는 네이버의 Maven 저장소\r\n\r\n// android/app/bundle.gradle\r\nimplementation("com.naver.maps:map-sdk:3.20.0")\r\n\r\n3.20 버전을 사용하라고 공식 문서에 되어있어요.\r\n\r\n// **android.enableJetifier=true** 는 Gradle 빌드 도구에 \r\n**자동 변환기(Jetifier)** 를 활성화하는 설정임.\r\n// 이 설정의 주요 목적은 기존의 Android Support 라이브러리를 새로운 \r\nAndroidX 라이브러리로 자동으로 변환하여 호환성을 유지하는 것\r\n// 프로젝트가 AndroidX를 사용하고 있는데, 일부 서드파티 라이브러리나\r\n종속성이 여전히 구 버전의 Support 라이브러리를 참조할 경우, Jetifier가 이를 AndroidX 형식으로 변환해 주어 충돌이나 호환성 문제 없이 함께 사용할 수 있게\r\n도와준다 ㄷㄷ. \r\n// 이를 통해 최신 라이브러리와 기존 라이브러리 간의 원활한 통합이 가능\r\n\r\n```\r\n- React-native-calendar\r\n- loading\r\n- https://loading.io/#editor\r\n- skeleton\r\n- swiper\r\n- ',
    markdown_title: '[네이티브] 퍼블리싱',
    summary:
      '아이콘 사용법\r\n\r\nIOS\r\nreact-native-vector-icons 라이브러리 (+types) 설치가 필요\r\nhttps://shiro21.tistory.com/475 감사 ㅠㅠ\r\n\r\n...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1735718508010,
    updated: 1735718508010,
    category: 'react-native',
    imageId: [],
    log: 0,
    markdown_contents:
      '\r\n```\r\n"@react-navigation/native": "^7.0.14",\r\n"@react-navigation/native-stack": "^7.2.0",\r\n"@react-navigation/stack": "^7.1.1",\r\n"react-native-safe-area-context": "^5.0.0",\r\n"react-native-screens": "^4.4.0"\r\n```\r\n\r\n **@react-navigation/native**\r\n\r\n- NavigationContainer 등을 제공하며, 라우팅/네비게이션 상태 관리를 담당.\r\n- 다른 네비게이션 타입(스택, 탭, 드로어)을 사용하기 위해서도 이 기본 패키지가 필요함.\r\n\r\n**@react-navigation/native-stack**\r\n\r\n- Native Stack Navigator를 구현하기 위한 패키지\r\n- iOS/Android에서 제공하는 네이티브 화면 전환 애니메이션을 활용하여, 퍼포먼스가 향상된 스택 네비게이션을 제공.\r\n- JS 기반의 애니메이션보다 더 부드럽고 플랫폼 고유의 느낌을 낼 수 있습니다.\r\n\r\n**@react-navigation/stack**\r\n\r\n- 전통적인 JavaScript 기반의 Stack Navigator를 사용하기 위한 패키지\r\n- 이전부터 많이 쓰이던 스택 네비게이션 구현체이며, 커스터마이징이 비교적 자유로운 편\r\n- 최근에는 native-stack과 비교해, 전환 애니메이션이 네이티브 방식보다 약간 덜 부드러울 수 있지만, 다양한 옵션을 지원함.\r\n\r\n**react-native-safe-area-context**\r\n\r\n- iOS 기기의 노치(Notch)나 안드로이드의 소프트 키 영역, 태블릿 등에서 안전 영역(Safe Area)을 자동으로 계산해주는 라이브러리\r\n- 상단/하단 등 안전 영역을 침범하지 않도록 안전한 패딩을 적용가능.\r\n- React Navigation에서도 내부적으로 화면 컨테이너를 안전하게 배치하기 위해 이 라이브러리를 활용\r\n\r\n**react-native-screens**\r\n\r\n- React Native 앱에서 네이티브 스크린 컴포넌트를 사용함으로써, 화면 전환 성능 개선 및 메모리 사용량 감소를 지원하는 라이브러리\r\n- React Navigation에서 더 빠른 스크린 전환이 가능하도록 권장 설치하는 패키지',
    markdown_title: '[네이티브] Navigation 시작',
    summary:
      '@react-navigation/native\r\nNavigationContainer 등을 제공하며, 라우팅/네비게이션 상태 관리를 담당.\r\n다른 네비게이션 타입(스택, 탭, 드로어)을 ...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1735718206637,
    updated: 1735718222256,
    category: 'react-native',
    imageId: [],
    log: 0,
    markdown_contents:
      '## IOS\r\n---\r\n### 설치 패키지\r\n> **brew install watchman**\r\nwatchman --version 으로 확인\r\n&nbsp;\r\n**sudo gem install cocoapods**\r\n-> Ruby의 관리자 접근 이슈\r\npod --version 으로 확인\r\n\r\n### 프로젝트 생성\r\n> **npx @react-native-community/cli init 프로젝트 명**\r\n&nbsp;\r\n이는 RN 0.76 버전부터 실행되는 커맨드임\r\n\r\n### IOS 실행\r\n- npx react-native run-ios\r\n\r\n당연하지만 XCode 역시 설치되어있어야 합니다.\r\n### 설치 실행중 오류\r\n\r\n**Error: EMFILE: too many open files**\r\n\r\n이 오류는 **파일 감시(watch) 제한에 걸려서 발생하는 대표적인 문제**\r\n\r\n**해결**\r\n- ulimit -n 의 디스크립터 수를 임시로 늘림\r\n- sudo launchctl limit maxfiles 524288 524288\r\n&nbsp;\r\n- watchman 설치\r\n- npx react-native start --reset-cache 캐시 리셋\r\n- node_modules 삭제 및 재 설치',
    markdown_title: '[네이티브] 설치 및 실행',
    summary: 'IOS\r\n\r\n설치 패키지',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1735552842351,
    updated: 1735701205078,
    category: 'algorithm',
    imageId: [],
    log: 0,
    markdown_contents:
      '## 개념\r\n\r\n리스트처럼 Node로 이루져있는 구조.\r\n\r\n- 링크드리스트는 노드가 앞뒤(전후)로 이루어져 있지만\r\n- 트리는 **노드가 가지처럼 여러가지**가 될 수 있다.\r\n- **비선형 구조**이며 경로가 여러갈래이다.\r\n\r\n특별한 점은 루트 (최상단)은 1개 여야 한다는 점. 그리고 같은 높이의 형제는 서로를 바라볼 수 없다는 점이다. \r\n\r\n### 이런 모양은 생각보다 많이 활용됩니다.\r\n- HTML DOM TREE : 너무 많이 알고있지만 대표적인 예시\r\n- 네트워크 라우팅\r\n- 인공지능 분야 (= 알파고 : 인간의 플레이 예측을 통한 트리구조의 의사결정)\r\n\r\n\r\n## 1. 이진 트리의 정의\r\n이진 트리(Binary Tree)는 각 노드가 최대 두 개의 자식 노드를 가지는 트리 자료 구조임. \r\n\r\n일반적으로 왼쪽 자식 노드와 오른쪽 자식 노드를 가지며, 이를 통해 데이터를 효율적으로 저장하고 관리 함. 이진 트리는 재귀적인 특성을 가지며, 각 서브트리도 이진 트리의 특성을 만족함.\r\n\r\n## 2. 이진 트리의 기본 특성\r\n- 자식 노드의 수: 각 노드는 최대 두 개의 자식 노드를 가질 수 있음.\r\n- 트리의 높이(Height): 루트 노드에서 가장 깊은 리프 노드까지의 경로 길이. 트리의 높이는 트리의 균형에 따라 달라짐\r\n- 균형(Balance): 트리의 왼쪽과 오른쪽 서브트리의 높이가 크게 차이나지 않도록 유지하는 것을 의미. **균형 잡힌 트리는 탐색과 같은 연산에서 성능이 향상**됨.\r\n\r\n&nbsp;\r\n\r\n### 이진 탐색트리\r\n는 데이터를 비교해서 정렬 가능하게 저장한다.\r\n\r\n\r\n![이미지 설명](https://api.chamchipack.com/api/files/6chhfppu6fpcdiq/gpegeqekp0soh67/blob_yGBZYnF7wd.png)\r\n\r\n예를들면 위와같이 루트가 33인데, 한 노드를 기준으로 그보다 작은것은 왼쪽으로, 큰 숫자는 오른쪽으로 정렬을 하는 방식이다.\r\n\r\n\r\n---\r\n이진 탐색트리는 순서가 있는 정렬 데이터를 가지고 탐색 작업을 함.\r\n\r\n\r\n### 직접 작성해보자\r\n```\r\nclass Node {\r\n    constructor(value) {\r\n        this.value = value;\r\n        this.left = null;\r\n        this.right = null;\r\n    }\r\n}\r\n\r\nclass BinarySearchTree {\r\n    constructor() {\r\n        this.root = null;\r\n    }\r\n\r\n     insert(value){\r\n        var newNode = new Node(value);\r\n        if(this.root === null){\r\n            this.root = newNode;\r\n            return this;\r\n        }\r\n        var current = this.root;\r\n        while(true){\r\n            if(value === current.value) return undefined;\r\n            if(value < current.value){\r\n                if(current.left === null){\r\n                    current.left = newNode;\r\n                    return this;\r\n                }\r\n                current = current.left;\r\n            } else {\r\n                if(current.right === null){\r\n                    current.right = newNode;\r\n                    return this;\r\n                } \r\n                current = current.right;\r\n            }\r\n        }\r\n    }\r\n\r\n      find(value){\r\n        if(this.root === null) return false;\r\n        var current = this.root,\r\n            found = false;\r\n        while(current && !found){\r\n            if(value < current.value){\r\n                current = current.left;\r\n            } else if(value > current.value){\r\n                current = current.right;\r\n            } else {\r\n                found = true;\r\n            }\r\n        }\r\n        if(!found) return undefined;\r\n        return current;\r\n    }\r\n    contains(value){\r\n        if(this.root === null) return false;\r\n        var current = this.root,\r\n            found = false;\r\n        while(current && !found){\r\n            if(value < current.value){\r\n                current = current.left;\r\n            } else if(value > current.value){\r\n                current = current.right;\r\n            } else {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\nvar tree = new BinarySearchTree();\r\ntree.root = new Node(10);\r\ntree.root.right = new Node(15);\r\ntree.root.left = new Node(7);\r\n```\r\n\r\n작성에 큰 어려움은 없었고, 위와같은 구조를 가지는것을 이해하는데에도 큰 어려움은 없었다. 역시나 가장 큰 것은 실제 적용이겠지.\r\n\r\n### 시간 복잡도\r\n- 삽입 : O(log n) 평균적으로 이 시간을 가지지만, 트리가 편향적으로 존재할 경우 O(n)의 시간복잡도를 가지는 경우도 있다고 함.\r\n- 탐색 : O(log n)\r\n',
    markdown_title: '[자료구조] 트리',
    summary:
      '개념\r\n\r\n리스트처럼 Node로 이루져있는 구조.\r\n링크드리스트는 노드가 앞뒤(전후)로 이루어져 있지만\r\n트리는 노드가 가지처럼 여러가지가 될 수 있다.\r\n비선형 구조이며 경로가 여러갈래이...',
    tag: [],
    theme: 'study',
    thumbnail:
      'https://api.chamchipack.com/api/files/6chhfppu6fpcdiq/gpegeqekp0soh67/blob_yGBZYnF7wd.png',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1735549716434,
    updated: 1735701200459,
    category: 'algorithm',
    imageId: [],
    log: 0,
    markdown_contents:
      '\r\n## 1. Stack\r\n**특징**\r\n- 후입선출(LIFO): 가장 최근에 삽입된 데이터가 가장 먼저 삭제된다.\r\n- 단방향성: 데이터는 한쪽 끝에서만 삽입(push)되고 삭제(pop)된다.\r\n- 순차적 접근: 스택 내부의 데이터를 임의로 접근할 수 없으며, 항상 최상단 데이터만 접근 가능\r\n\r\n&nbsp;\r\n\r\n배열로도 할 수 있고, 인덱스도 필요 없고, 링크드리스트로 작성 가능하다. 필요한것은 push나 pop과 같은 로직에 따라서 수행할 수 있는 기능이다.\r\n\r\n&nbsp;\r\n\r\n### 시간 복잡도\r\n- Push: O(1) - 최상단에 데이터를 추가하는 연산 = 상수 시간\r\n- Pop: O(1) - 최상단 데이터를 제거하는 연산도 상수 시간\r\n- Peek/Top: O(1) - 최상단 데이터를 조회하는 연산도 상수 시간\r\n- isEmpty: O(1) - 스택이 비어있는지 확인하는 연산도 상수 시간\r\n- size: O(1) - 스택의 크기를 반환하는 연산도 상수 시간\r\n\r\n---\r\n\r\n단방향 링크드리스트와 비슷해 보이지만 그것의 Pop과는 조금 다른 개념이 있다. LinkedList의 Pop은 **반복문을 통해서 O(n)의 시간**동안 Pop 해야할 대상을 찾아가야 한다.\r\n\r\n그러나 Stack의 Pop은 **가장 나중에 들어온 데이터에 대한 메소드** 이기 때문에 시간 복잡도 자체가 다를 수 밖에 없다.\r\n\r\n## 2. Queue\r\n\r\n**특징**\r\n- 선입선출(FIFO): 먼저 삽입된 데이터가 먼저 제거됨.\r\n- 단방향성: 데이터는 한쪽 끝(뒤쪽)에서만 삽입(enqueue)되고, 다른 쪽 끝(앞쪽)에서만 제거(dequeue)된다.\r\n- 순차적 접근: 큐 내부의 데이터를 임의로 접근할 수 없으며, 항상 앞쪽(front)과 뒤쪽(rear)에서만 접근 가능.\r\n\r\n&nbsp;\r\n\r\n배열로 만든 큐는 선입선출 과정에서 메모리의 많은 사용과 인덱스의 잦은 변경이 예상 되기때문에, 링크드리스트를 이용한 제작이 필요해 보인다\r\n\r\n```\r\nclass Node {\r\n  constructor(data) {\r\n    this.data = data;\r\n    this.next = null;\r\n  }\r\n}\r\n\r\nclass LinkedListQueue {\r\n  constructor() {\r\n    this.front = null;\r\n    this.rear = null;\r\n    this.count = 0;\r\n  }\r\n\r\n  // Enqueue 연산\r\n  enqueue(element) {\r\n    const node = new Node(element);\r\n    if (this.rear) {\r\n      this.rear.next = node;\r\n    }\r\n    this.rear = node;\r\n    if (!this.front) {\r\n      this.front = node;\r\n    }\r\n    this.count++;\r\n  }\r\n\r\n  // Dequeue 연산\r\n  dequeue() {\r\n    if (this.isEmpty()) {\r\n      throw new Error("Queue Underflow");\r\n    }\r\n    const dequeued = this.front.data;\r\n    this.front = this.front.next;\r\n    if (!this.front) {\r\n      this.rear = null;\r\n    }\r\n    this.count--;\r\n    return dequeued;\r\n  }\r\n\r\n  // Peek 연산\r\n  peek() {\r\n    if (this.isEmpty()) {\r\n      throw new Error("Queue is Empty");\r\n    }\r\n    return this.front.data;\r\n  }\r\n\r\n  // isEmpty 연산\r\n  isEmpty() {\r\n    return this.front === null;\r\n  }\r\n\r\n  // size 연산\r\n  size() {\r\n    return this.count;\r\n  }\r\n}\r\n\r\n// 사용 예시\r\nconst queue = new LinkedListQueue();\r\nqueue.enqueue(1);\r\nqueue.enqueue(2);\r\nconsole.log(queue.dequeue()); // 출력: 1\r\nconsole.log(queue.peek());    // 출력: 2\r\n\r\n```\r\n\r\n### 시간복잡도\r\n\r\n- Enqueue: O(1) - 큐의 뒤쪽에 데이터를 추가하는 연산은 상수 \r\n- Dequeue: O(1) - 큐의 앞쪽 데이터를 제거하는 연산도 상수 시간\r\n- Peek/Front: O(1) - 큐의 앞쪽 데이터를 조회하는 연산도 상수\r\n',
    markdown_title: '[자료구조] 스택 + 큐 ',
    summary:
      '1. Stack\r\n특징\r\n후입선출(LIFO): 가장 최근에 삽입된 데이터가 가장 먼저 삭제된다.\r\n단방향성: 데이터는 한쪽 끝에서만 삽입(push)되고 삭제(pop)된다.\r\n순차적 접근:...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1735278670805,
    updated: 1735701196907,
    category: 'algorithm',
    imageId: [],
    log: 0,
    markdown_contents:
      '### 개념\r\n- 단일 연결 리스트 + 이전것을 확인할 수 있는 포인터(?) 가 있다는것\r\n- 메모리가 더 드는 효과가 있음. next + previous 까지 저장하니까\r\n\r\n```\r\n(1, 2, 3, 4, 5) \r\n// 단일 연결리스트는 1 => 5 방향만 가능하지만\r\n// 이중 연결리스트는 5 => 1 방향으로 탐색이 가능\r\n```\r\n### 차이점\r\n---\r\n단일 연결 리스트와 차이는 prev 라는 지시 포인터가 있는지 여부이다. 단일 자체는 한 방향으로만 탐색 하기 때문에 **역방향에 제한**이 걸려있지만, 이중 연결리스트는 한 위치를 중심으로 **양방향 탐색**이 가능한 점이 있다.\r\n\r\n메모리를 더 할당한다고는 하지만 성능이슈가 발생된 케이스가 있을까 라는 생각이 든다. 어찌되었든지, 실제 브라우저 히스토리 검색에 이중 연결 리스트가 사용된다고 한다. 앞뒤 이동이 용이한 부분에서 이중 리스트의 사용성이 대두될 것 같다.\r\n\r\n\r\n### 복잡도\r\n- 삽입 : 상수시간\r\n- 제거 : 상수시간\r\n- 접근, 검색 : O(n)',
    markdown_title: '[자료구조] 이중 링크드 리스트',
    summary:
      '개념\r\n단일 연결 리스트 + 이전것을 확인할 수 있는 포인터(?) 가 있다는것\r\n메모리가 더 드는 효과가 있음. next + previous 까지 저장하니까\r\n\r\n\r\n차이점\r\n\r\n단일 연결 리...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1735026158931,
    updated: 1735701190946,
    category: 'algorithm',
    imageId: [],
    log: 0,
    markdown_contents:
      '### 기본 개념\r\n- 배열같이 다수의 데이터를 저장한다.\r\n\r\n- 배열같이 가리키는 인덱스는 없고, 연결된 기차와 같다.\r\n- 순서대로 접근할 수 있다.\r\n\r\n- 다수의 노드로 구성되어 있고, 각각의 노드는 문자열 혹은 숫자와 같은 하나의 데이터 엘리먼트를 저장한다.\r\n\r\n- 가장 앞을 Head, 마지막을 Tail 이라고 한다. \r\n\r\n&nbsp;\r\n\r\n### 작동예시\r\n\r\n```\r\n(1, 2, 3, 4, 5)\r\n// 위와같은 링크드리스트가 있다고 가정해봅시다.\r\n\r\n// 3이라는 데이터를 찾으려면 헤드 (1) 부터 순차적으로 \r\n접근해서  1 => 2=> 3 을 찾아야 한다.\r\n\r\n// 만약 3과 4사이에 9 라는 데이터를 추가하려면?\r\n// 마찬가지로 1 => 2=> 3 => 4 에 접근해서 \r\n사이에 노드를 하나 추가하고 앞 뒤의 노드 정보를 바꿔준다\r\n```\r\n\r\n배열의 인덱스 개념이 없기때문에, **연속된 메모리 공간을 사용하지 않고**, 각 노드가 **다음 노드를 가리키는 포인터**를 통해 연결한다\r\n\r\n&nbsp;\r\n### 만들어보자\r\n\r\n```\r\nclass Node {\r\n  constructor(val) {\r\n    this.val = val;\r\n    this.next = null; \r\n  }\r\n}\r\n\r\nclass SinglyLinkedList {\r\n  constructor() {\r\n    this.head = null; \r\n    this.tail = null; \r\n    this.length = 0;  \r\n  }\r\n}\r\n\r\nvar list = new SinglyLinkedList();\r\n```\r\n\r\n단일 링크드리스트를 만들어보았다. 리스트는 노드로 이루어져 있기때문에 클래스는 2개를 만든다.\r\n\r\n링크드 리스트는 Head와 Tail로 되어있고, 각 데이터들은 "노드" 라고 불린다는 점을 기억해야 한다. \r\n\r\n\r\n### 데이터 입력 (Push? Append?)\r\n\r\npush라는 메소드를 작성해서 링크드 리스트를 만들어보자. 그 인스턴스는 아래와 같다\r\n\r\n```\r\nclass SinglyLinkedList {\r\n...\r\n push(val) {\r\n    const newNode = new Node(val); \r\n\r\n    if (!this.head) {\r\n      this.head = newNode;\r\n      this.tail = newNode;\r\n    } else {\r\n      this.tail.next = newNode;\r\n      this.tail = newNode; \r\n    }\r\n    this.length++; \r\n  }\r\nvar list = new SinglyLinkedList();\r\nlist.push(10)\r\nlist.push(20)\r\nlist.push(30)\r\n\r\n// 결과는 아래\r\nlist = {\r\n    "head": {\r\n        "val": 10,\r\n        "next": {\r\n            "val": 20,\r\n            "next": {\r\n                "val": 30,\r\n                "next": null\r\n            }\r\n        }\r\n    },\r\n    "tail": {\r\n        "val": 30,\r\n        "next": null\r\n    },\r\n    "length": 3\r\n}\r\n```\r\n시작 (Head)과 끝 (Tail)이 있고, 각각의 노드가 next로 연결된 점을 알 수 있다. index로 찾는 기존의 배열과는 확연히 다른 모습이 분명하다. \r\n\r\n### 데이터 제거 (pop)\r\n\r\n제거는 고려해야할 것이 좀 더 많은 느낌이다.\r\n\r\n- 반복문으로 next를 넘겨가며 Tail을 찾는다\r\n- Tail 앞의 데이터를 pre로 저장해둔 다음\r\n- pre 를 Tail로 설정해주고 기존 Tail은 날려버린다.\r\n```\r\n    pop() {\r\n        if (!this.head) return null\r\n\r\n        if (this.length === 1) {\r\n            const poppedNode = this.head;\r\n            this.head = null;\r\n            this.tail = null;\r\n            this.length = 0;\r\n            return poppedNode\r\n        }\r\n\r\n        let current = this.head\r\n        let pre = null;\r\n        while (current.next) {\r\n            pre = current;\r\n            current = current.next\r\n        }\r\n\r\n        this.tail = pre;\r\n        this.tail.next = null;\r\n        this.length--;\r\n\r\n        return current;\r\n    }\r\n```\r\n이후 get() set() .... remove() 까지 코드를 보았다. 결과적으로 어떤 상황에서 쓰이냐에 대한 의문을 감출 수가 없었다.\r\n\r\n사실 실제 쓰임새를 아직 보지 못하여, 기존 배열과 비교했을때 무엇이 효율적인지는 아직 알 수 없다.\r\n\r\n### 이럴때\r\n- 하나의 리스트에서 **특정 삽입이나 삭제가 빈번할 경우**\r\n\r\n결과적으로 기존 배열은 인덱스값의 특정 때문에 중간 삽입과 삭제 부분으로 인해 많은 연산 작업을 거쳐야 할 것이다. 그러나 리스트는 해당 없음이기 때문에 사용에는 적절한 생각이 든다. \r\n\r\n그러나 리스트의 탐색이 자주 일어난다면 리스트는 오히려 손해가 될 가능성이 있고, 빈번한 추가 또한 리스트에서는 메모리 사용량이 증가될 수 있음을 고려해야한다.\r\n\r\n\r\n\r\n\r\n```\r\nclass Node{\r\n    constructor(val){\r\n        this.val = val;\r\n        this.next = null;\r\n    }\r\n}\r\n\r\nclass SinglyLinkedList{\r\n    constructor(){\r\n        this.head = null;\r\n        this.tail = null;\r\n        this.length = 0;\r\n    }\r\n    push(val){\r\n        var newNode = new Node(val);\r\n        if(!this.head){\r\n            this.head = newNode;\r\n            this.tail = this.head;\r\n        } else {\r\n            this.tail.next = newNode;\r\n            this.tail = newNode;\r\n        }\r\n        this.length++;\r\n        return this;\r\n    }\r\n    pop(){\r\n        if(!this.head) return undefined;\r\n        var current = this.head;\r\n        var newTail = current;\r\n        while(current.next){\r\n            newTail = current;\r\n            current = current.next;\r\n        }\r\n        this.tail = newTail;\r\n        this.tail.next = null;\r\n        this.length--;\r\n        if(this.length === 0){\r\n            this.head = null;\r\n            this.tail = null;\r\n        }\r\n        return current;\r\n    }\r\n    shift(){\r\n        if(!this.head) return undefined;\r\n        var currentHead = this.head;\r\n        this.head = currentHead.next;\r\n        this.length--;\r\n        if(this.length === 0){\r\n            this.tail = null;\r\n        }\r\n        return currentHead;\r\n    }\r\n    unshift(val){\r\n        var newNode = new Node(val);\r\n        if(!this.head) {\r\n            this.head = newNode;\r\n            this.tail = this.head;\r\n        }\r\n        newNode.next = this.head;\r\n        this.head = newNode;\r\n        this.length++;\r\n        return this;\r\n    }\r\n    get(index){\r\n        if(index < 0 || index >= this.length) return null;\r\n        var counter = 0;\r\n        var current = this.head;\r\n        while(counter !== index){\r\n            current = current.next;\r\n            counter++;\r\n        }\r\n        return current;\r\n    }\r\n    set(index, val){\r\n        var foundNode = this.get(index);\r\n        if(foundNode){\r\n            foundNode.val = val;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    insert(index, val){\r\n        if(index < 0 || index > this.length) return false;\r\n        if(index === this.length) return !!this.push(val);\r\n        if(index === 0) return !!this.unshift(val);\r\n        \r\n        var newNode = new Node(val);\r\n        var prev = this.get(index - 1);\r\n        var temp = prev.next;\r\n        prev.next = newNode;\r\n        newNode.next = temp;\r\n        this.length++;\r\n        return true;\r\n    }\r\n    remove(index){\r\n        if(index < 0 || index >= this.length) return undefined;\r\n        if(index === 0) return this.shift();\r\n        if(index === this.length - 1) return this.pop();\r\n        var previousNode = this.get(index - 1);\r\n        var removed = previousNode.next;\r\n        previousNode.next = removed.next;\r\n        this.length--;\r\n        return removed;\r\n    }\r\n    reverse(){\r\n      var node = this.head;\r\n      this.head = this.tail;\r\n      this.tail = node;\r\n      var next;\r\n      var prev = null;\r\n      for(var i = 0; i < this.length; i++){\r\n        next = node.next;\r\n        node.next = prev;\r\n        prev = node;\r\n        node = next;\r\n      }\r\n      return this;\r\n    }\r\n    print(){\r\n        var arr = [];\r\n        var current = this.head\r\n        while(current){\r\n            arr.push(current.val)\r\n            current = current.next\r\n        }\r\n        console.log(arr);\r\n    }\r\n}\r\n\r\nvar list = new SinglyLinkedList()\r\n\r\nlist.push(100)\r\nlist.push(201)\r\nlist.push(250)\r\nlist.push(350)\r\nlist.push(999)\r\n\r\n```\r\n\r\n',
    markdown_title: '[자료구조] 단방향 링크드 리스트',
    summary:
      '기본 개념\r\n배열같이 다수의 데이터를 저장한다.\r\n배열같이 가리키는 인덱스는 없고, 연결된 기차와 같다.\r\n순서대로 접근할 수 있다.\r\n다수의 노드로 구성되어 있고, 각각의 노드는 문자열...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1735019683747,
    updated: 1735019683747,
    category: 'algorithm',
    imageId: [],
    log: 0,
    markdown_contents:
      "## 개념\r\n---\r\n피벗이라는 기준 숫자를 가지고 피벗보다 큰 숫자, 작은 숫자를 분할 한 후 정렬을 이어가는 방식\r\n\r\n\r\n&nbsp;\r\n### 예시\r\n```\r\n[5, 2, 9, 1, 7]\r\n// 5를 피벗으로 두고 비교한다.\r\n// 반복해가며 5보다 작은 수, 큰 수를 비교한다\r\n\r\n[2, 1, 5, 9, 7]\r\n// 이와같이 될것이다. 이렇게 되면 5의 위치는 고정값이 될것임.\r\n그리고 다시 5의 앞에서부터 피벗을 재설정하고 비교한다\r\n[2, 1] 은 [1, 2] 가 될것이고\r\n[9, 7] 은 [7, 9] 가 될것이다.\r\n```\r\n\r\n## 핵심\r\n---\r\n- 피벗 선택 : **배열에서 임의 혹은 특정 위치의 원소를 '피벗'으로 선택** (보통은 맨 앞, 맨 뒤, 혹은 중앙값 등)\r\n\r\n- 분할 : **피벗을 기준으로, 피벗보다 작은 값들은 왼쪽, 피벗보다 큰 값들은 오른쪽으로 분류**\r\n\r\n이렇게 하면 피벗은 최종적으로 ‘정렬된 상태에서의 정확한 위치’에 놓이게 된다.\r\n재귀 피벗의 왼쪽 부분 배열과 오른쪽 부분 배열에 대해서, 같은 과정을 반복함.\r\n\r\n왼쪽 부분 배열도 ‘피벗 선택 → 분할 → 재귀’\r\n오른쪽 부분 배열도 ‘피벗 선택 → 분할 → 재귀’\r\n\r\n- 배열의 크기가 1 이하가 되면 재귀를 멈춥니다(이미 정렬된 상태).\r\n\r\n- 하나의 피벗을 기준으로 배열을 둘로 나눈 뒤, 그 두 부분 배열도 같은 방식으로 반복해서 쪼개 나가는 구조\r\n\r\n### 시간 복잡도\r\n---\r\n**평균/평상시**\r\n\r\nO(nlogn)\r\n\r\n분할 과정에서 매번 대략 반반씩 나누어지는 경우, 실제로 많은 랜덤 데이터에서 빠르게 동작\r\n\r\n**분할 과정이 극단적으로 편향되게 일어날 때**\r\n\r\n~~예를 들어 이미 정렬된 배열을 매번 맨 앞(또는 맨 뒤)을 피벗으로 선택하거나, 피벗이 계속 최솟값 혹은 최댓값이 되어버리는 상황~~\r\n\r\n- **선형 탐색 + 재귀가 계속 반복되는 경우가 존재함**\r\n\r\n이를 방지하기 위해 랜덤 피벗을 선택하거나, 가운데 세 값 중 중간값(Median of three) 피벗을 선택하는 등의 방법으로 최악의 경우를 낮추는 기법이 사용된다고 한다.\r\n\r\n\r\n\r\n",
    markdown_title: '[알고리즘] 퀵 정렬',
    summary:
      '개념\r\n\r\n피벗이라는 기준 숫자를 가지고 피벗보다 큰 숫자, 작은 숫자를 분할 한 후 정렬을 이어가는 방식\r\n\r\n\r\n&nbsp;\r\n예시\r\n\r\n\r\n핵심\r\n피벗 선택 : 배열에서 임의 혹은 특정 위치의...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1734949897226,
    updated: 1735701182392,
    category: 'algorithm',
    imageId: [],
    log: 0,
    markdown_contents:
      '## 개념\r\n---\r\n1948년에 진공관 코드로 고안되었음.\r\n\r\n분할, 정렬, 합병 이 세가지로 이루어진 정렬 방법\r\n\r\n배열을 더 분할해서 더 작은 하위 배열로 만들어놓은 뒤, 0개 내지 1개의 하위 배열로 만든 다음 병합시킨다.\r\n\r\n### 예시\r\n---\r\n\r\n```\r\n[8, 3, 5, 4, 7, 6, 1, 2] // 원래 배열 모양\r\n[8, 3, 5, 4] [7, 6, 1, 2] // 분할\r\n[8, 3] [5, 4] [7, 6] [1, 2] // 분할22\r\n[8] [3] [5] [4] [7] [6] [1] [2] // 분할333\r\n[3, 8] [4, 5] [6, 7] [1, 2] // 비교 및 합병\r\n...\r\n[1, 2, 3, 4, 5, 6, 7, 8] // 합병 완료\r\n```\r\n\r\n&nbsp;\r\n### 핵심\r\n---\r\n- 분할하는 로직1개, 정렬하는 로직 1개로 분리한다.\r\n- 정렬하는 로직은 다중 포인터 방식으로 순서를 정렬시킨 다음 리턴하도록 한다.\r\n\r\n&nbsp;\r\n### 보자\r\n---\r\n```\r\n// 합병 및 정렬하는 함수\r\nfunction merge(arr1, arr2){\r\n    let results = [];\r\n    let i = 0;\r\n    let j = 0;\r\n    while(i < arr1.length && j < arr2.length){\r\n        if(arr2[j] > arr1[i]){\r\n            results.push(arr1[i]);\r\n            i++;\r\n        } else {\r\n            results.push(arr2[j])\r\n            j++;\r\n        }\r\n    }\r\n    while(i < arr1.length) {\r\n        results.push(arr1[i])\r\n        i++;\r\n    }\r\n    while(j < arr2.length) {\r\n        results.push(arr2[j])\r\n        j++;\r\n    }\r\n    return results;\r\n}\r\n\r\n// 분할하는 로직 (재귀함수로 배열을 죽자고 분할시킨다)\r\nfunction mergeSort(arr){\r\n    if(arr.length <= 1) return arr; // 1개 크기 나올때까지\r\n\r\n    let mid = Math.floor(arr.length/2);\r\n    let left = mergeSort(arr.slice(0,mid));\r\n    let right = mergeSort(arr.slice(mid));\r\n    return merge(left, right);\r\n}\r\n\r\nmergeSort([10,24,76,73])\r\n ```\r\n\r\n### 피부로 느낀점\r\n---\r\n**배열이 분할 가능한 구조여야 할것.**\r\n\r\n**재귀(또는 반복)적으로 분할과 합병이 가능해야 할것.**\r\n\r\n즉, 나눌 수 있고, 나눈것을 다시 합병해서 만들 수 있느냐.\r\n\r\n\r\n\r\n- 시간 복잡도가 일관적으로  𝑂(𝑛 log 𝑛) : 최악도 최선도 배열의 합친 값인 것\r\n- 분할을 하기때문에 추가적으로 메모리가 사용이 된다는 점은 감안 해야한다.',
    markdown_title: '[알고리즘] 합병 정렬',
    summary:
      '개념\r\n\r\n1948년에 진공관 코드로 고안되었음.\r\n\r\n분할, 정렬, 합병 이 세가지로 이루어진 정렬 방법\r\n\r\n배열을 더 분할해서 더 작은 하위 배열로 만들어놓은 뒤, 0개 내지 1개의 하...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1734941703359,
    updated: 1734941703359,
    category: 'algorithm',
    imageId: [],
    log: 0,
    markdown_contents:
      '## 개념\r\n---\r\n배열의 과반을 점차적으로 만들어 정렬을 구축\r\n\r\n각 요소를 취하여 정렬되어 있는 절반 속 해당되는 위치에 배치한다. \r\n\r\n즉, 일부분이 정렬이 되어있다고 가정한 상태에서, 대상이 되는 요소를 정렬된 부분에 알맞게 삽입하는 형태이다. 어떻게 보면 버블이나 선택이 혼합된 느낌이 든다\r\n\r\n&nbsp;\r\n### 예시\r\n---\r\n```\r\n[5, 3, 4, 1, 2]\r\n5를 기준삼고 3과 비교하여 정렬된 부분에서 어디에 둘지 파악한다.\r\n[3, 5, 4, ,1, 2]\r\n3, 5를 기준삼고 4와 비교하여 정렬된 부분에서 어디에 둘지 파악한다.\r\n[3, 4, 5, 1, 2]\r\n3, 4, 5를 기준삼고 1을 비교한다. \r\n1은 5, 4, 3을 순서대로 비교하여 이동한다\r\n[1, 3, 4, 5, 2] ..... 이런 순서임\r\n```\r\n\r\n## 해봐\r\n---\r\n```\r\nfunction insertionSort(arr) {\r\n\r\n//  0번인덱스는 정렬이 되어있다고 가정하기 때문에 1번부터 비교한다\r\n    for (let i = 1; i < arr.length; i++) {\r\n        let currentVal = arr[i] // 비교군\r\n\r\n        let j;\r\n        for (j = i - 1; j >= 0 && arr[j] > currentVal; j--) {\r\n//  비교군보다 앞에있는 요소들과 비교를 하는데, \r\n//  비교군이 대상요소보다 작지 않으면 그자리에 남기는것임.\r\n            arr[j+1] = arr[j]\r\n        }\r\n\r\n        arr[j+1] = currentVal\r\n    }\r\n  \r\n    \r\n    return arr;\r\n}\r\n\r\nconsole.log(insertionSort([3,1,2,76,4]));\r\n```\r\n확실히 조금더 복잡했고, 이해하기가 처음엔 난해했다. 보아하니 조건을 잘 생각해야 헷갈림을 방지할 수 있는것 같다. \r\n\r\n- 비교대상인 currentVal 현재숫자는, 그보다 왼쪽의 정렬되어있는 수와 비교를 한다는 것.\r\n- 당연하게도 currentVal이 비교대상보다 작아야 왼쪽으로 숫자를 옮길 수 있다는 것.\r\n\r\n## 핵심\r\n---\r\n- 데이터가 정렬안된 난잡한 상태라면 기본적으로 n2의 시간이 걸릴것이다. \r\n- \b역방향으로 정렬 되어있는데 이를 순방향으로 바꿔야 하는 가정이라면 최악의 상황이다.\r\n- 정렬이 된 어떤 배열에서, 데이터가 하나씩 추가가 된 상황이라면 좋은 방법일 수 있다.\r\n',
    markdown_title: '[알고리즘] 삽입 정렬',
    summary:
      '개념\r\n\r\n배열의 과반을 점차적으로 만들어 정렬을 구축\r\n\r\n각 요소를 취하여 정렬되어 있는 절반 속 해당되는 위치에 배치한다. \r\n\r\n즉, 일부분이 정렬이 되어있다고 가정한 상태에서, 대상...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1734928619845,
    updated: 1734930346505,
    category: 'algorithm',
    imageId: [],
    log: 0,
    markdown_contents:
      '## 개념\r\n---\r\n버블정렬처럼 큰 값을 맨 오른쪽에 두는 대신, 작은 값을 한번에 하나 씩 위치에 배열한다.\r\n\r\n마찬가지로 처음부터 끝까지 움직이지만, 실제 정렬된 데이터는 처음부터 누적되고 있다.\r\n\r\n버블과 다른점은, 버블은 잠재적으로 큰 수를 계속 뒤로 밀어내지만, 선택은 **최소값을 찾아서 루프 마지막에 맨 앞과 바꾸는 것**이다.\r\n\r\n---\r\n### 예시\r\n```\r\n[5, 3, 4, 1, 2]\r\n5와 3을 비교한다. 3을 최소값으로 저장한다.\r\n3와 4를 비교한다. 3이 여전히 최소값이다.\r\n3와 1을 비교한다. 1을 최소값으로 바꾼다.\r\n1와 2를 비교한다. 1이 최소값이기 때문에 아래의 결과가 나온다.\r\n\r\n[1, 3, 4, 5, 2]\r\n\r\n1회 반복을 한 결과, 기존의 맨 앞에 있던 5와 최소값 1의 위치가 변경 되었다.\r\n```\r\n\r\n---\r\n### 해보자\r\n\r\n```\r\nfunction selection(arr) {\r\n    \r\n    for (let i = 0; i < arr.length - 1; i++) {\r\n        let minIndex = i;\r\n        \r\n        for (let j = i + 1; j < arr.length; j++) {\r\n            if (arr[minIndex] > arr[j]) {\r\n                minIndex = j\r\n            }\r\n        }    \r\n         if (minIndex !== i) {\r\n             [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]\r\n         }\r\n\r\n    }\r\n}\r\n\r\nselection([15, 32, 7, 20, 2])\r\n```\r\n\r\n코드를 작성했을때, 생각한만큼 복잡한 로직이 아니었다. 가장 작은 수와 현재 인덱스의 수를 바꿔주기만 하면 되었기 때문이다. \r\n\r\n실제로 모든 요소를 비교해야 하기때문에, 배율이 늘어날 수록 n의 제곱으로 비교해야하는건 사실이다.\r\n\r\n## 언제\r\n---\r\n선택정렬이 잠재적으로 버블보다 나을 때는, 어떤 상황으로 스왑의 수를 최소화 할때이다.\r\n\r\n버블을 다시 생각해보면, 매 과정마다 스왑이 자주 일어나기 때문에, 해당 스왑의 과정을 줄여야 한다면 선택 정렬이 나을지도 모른다. \r\n\r\n물론 메모리를 건드리는 그런.... 경우가 있는지는 모르겠는데, 어쨌든 그런 상황에는 선택이 훨씬 나을거란 이야기 이다.\r\n\r\n',
    markdown_title: '[알고리즘] 선택정렬',
    summary:
      '개념\r\n\r\n버블정렬처럼 큰 값을 맨 오른쪽에 두는 대신, 작은 값을 한번에 하나 씩 위치에 배열한다.\r\n\r\n마찬가지로 처음부터 끝까지 움직이지만, 실제 정렬된 데이터는 처음부터 누적되고 ...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1734764159673,
    updated: 1734927859383,
    category: 'algorithm',
    imageId: [],
    log: 0,
    markdown_contents:
      'https://visualgo.net/en/sorting\r\n\r\n## 개념\r\n---\r\n배열을 오름차순으로 정렬을 한다는 가정하에, 더 큰 숫자가 한 번에 하나씩 뒤로 이동을 한다는 것.\r\n\r\n### 정렬 방식\r\n\r\n```\r\n[5, 3, 4, 1, 2] // 기본 모양\r\n[3, 5, 4, 1, 2] // 1회\r\n[3, 4, 5, 1, 2] // 2회\r\n[3, 4, 1, 5, 2] ...\r\n[3, 4, 1, 2, 5] ... 더 큰 숫자를 한번에 하나씩 이동\r\n```\r\n이 방식을 계속 반복한다. \r\n\r\n### 복잡도 계산\r\n- 시간 : 사실상 O(n2) -> 매 비교마다 스왑이 일어나야 한다면 최악이다.\r\n- 공간 : 인접한 요소에 대한 교환이기 때문에 O(1)\r\n\r\n&nbsp;\r\n\r\n### 핵심\r\n---\r\n- 큰 숫자를 하나씩 뒤로 이동하여 정렬한다.\r\n- 반복 횟수를 거칠수록 정렬해야하는 항목 수는 감소한다.\r\n> 크기 6의 배열을 반복한다면, 처음엔 6번검사, 그 다음은 5번검사, 4번 검사... 이렇게 줄어든다는 의미이다. (검사마다 가장 큰 숫자가 오른쪽으로 이동 하니까)\r\n\r\n이 핵심을 생각하며 반복문으로 예시를 가져보자.\r\n\r\n&nbsp;\r\n### 예시\r\n---\r\n\r\n```\r\nfunction 버블정렬(arr){\r\n  for(var i = 0; i < arr.length; i++){\r\n    for(var j = 0; j < arr.length; j++){\r\n      console.log(arr, arr[j], arr[j+1]);\r\n      if(arr[j] > arr[j+1]){\r\n        var temp = arr[j];\r\n        arr[j] = arr[j+1];\r\n        arr[j+1] = temp;         \r\n      }\r\n    }\r\n  }\r\n  return arr;\r\n}\r\n\r\n[ 37, 45, 29, 8 ] 37 45\r\n[ 37, 45, 29, 8 ] 45 29\r\n[ 37, 29, 45, 8 ] 45 8\r\n[ 37, 29, 8, 45 ] 45 undefined\r\n[ 37, 29, 8, 45 ] 37 29\r\n[ 29, 37, 8, 45 ] 37 8\r\n[ 29, 8, 37, 45 ] 37 45\r\n[ 29, 8, 37, 45 ] 45 undefined\r\n[ 29, 8, 37, 45 ] 29 8\r\n[ 8, 29, 37, 45 ] 29 37\r\n[ 8, 29, 37, 45 ] 37 45\r\n[ 8, 29, 37, 45 ] 45 undefined\r\n[ 8, 29, 37, 45 ] 8 29\r\n[ 8, 29, 37, 45 ] 29 37\r\n[ 8, 29, 37, 45 ] 37 45\r\n[ 8, 29, 37, 45 ] 45 undefined\r\n```\r\n일반적인 순방향으로 반복문을 사용하면, 45숫자는 1회 순환으로 맨뒤를 찾아갔으나,  j + 1 이라는 규칙때문에 undefined와 비교하는 상황이 발생되고, 핵심에서의 2번 항목과는 거리가 먼 계산이 나오게 된다. \r\n\r\n이를 방지하고 핵심대로 하기 위해서는, 배열 반복 조건을 바꾸면 된다.\r\n\r\n```\r\nfunction bubbleSort(arr){\r\n  for(var i = arr.length; i > 0; i--){\r\n    for(var j = 0; j < i - 1; j++){\r\n      console.log(arr, arr[j], arr[j+1]);\r\n      if(arr[j] > arr[j+1]){\r\n        var temp = arr[j];\r\n        arr[j] = arr[j+1];\r\n        arr[j+1] = temp;         \r\n      }\r\n    }\r\n  }\r\n  return arr;\r\n}\r\n\r\n[ 37, 45, 29, 8 ] 37 45\r\n[ 37, 45, 29, 8 ] 45 29\r\n[ 37, 29, 45, 8 ] 45 8\r\n[ 37, 29, 8, 45 ] 37 29\r\n[ 29, 37, 8, 45 ] 37 8\r\n[ 29, 8, 37, 45 ] 29 8\r\n```\r\n\r\n즉, 매 반복회차마다 배열의 비교 범위를 1씩 줄이면서 오른쪽 맨 끝 자리는 이미 정렬이 끝났다고 보고 제외하여, 훨씬 효율적인 정렬을 이룰수 있게 된다. \r\n\r\n### 최적화\r\n\r\n하지만 위의 경우에서는, 가장 큰 수가 배열의 맨 오른쪽에 도착 했더라도, 반복문을 루프 돌때는 배열의 처음부터 끝까지 계속 루프를 하게 된다. 이미 가장 큰 수가 끝에 도달 했는데도 말이다. \r\n\r\n즉, 정렬이 끝난 루프는 더이상 반복하지 않게 최적화를 해줘야한다. 아래는 최적화의 예시이다. \r\n\r\n```\r\nfunction bubbleSort(arr){\r\n    let noSwaps;\r\n    \r\n  for(var i = arr.length; i > 0; i--){\r\n      noSwaps = true;\r\n    for(var j = 0; j < i - 1; j++){\r\n      if(arr[j] > arr[j+1]){\r\n        var temp = arr[j];\r\n        arr[j] = arr[j+1];\r\n        arr[j+1] = temp;         \r\n        noSwaps = false;\r\n      }\r\n      console.log(arr, arr[j], arr[j+1]);\r\n    }\r\n      if (noSwaps) break;\r\n  }\r\n  return arr;\r\n}\r\n```\r\n\r\n단순한 boolean으로 구분하여 스왑이 되지 않았으면 반복을 멈춰서, 더이상의 불필요한 반복이 발생하지 않도록 하는 것 이다. \r\n\r\n## 결론\r\n---\r\n- 버블정렬은 두개 중 더 큰 숫자를 뒤로 한번씩 보낸다\r\n- 배열의 크기만큼 O(n2)의 시간이 걸린다. \r\n- 거의 정렬이 완료된 배열이어야 그나마 시간복잡도에서의 최악을 면할 수 있다.\r\n- 쓸모없는 반복을 없애도록 최적화를 열심히 해야한다.',
    markdown_title: '[알고리즘] 버블 정렬',
    summary:
      'https://visualgo.net/en/sorting\r\n\r\n개념\r\n\r\n배열을 오름차순으로 정렬을 한다는 가정하에, 더 큰 숫자가 한 번에 하나씩 뒤로 이동을 한다는 것.\r\n\r\n정렬 방식\r\n...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1734751302626,
    updated: 1734941970351,
    category: 'algorithm',
    imageId: [],
    log: 0,
    markdown_contents:
      '## 왜 배우는 것일까\r\n\r\n데이터를 정렬 시키는데에는 많은 방법들이 있다. 가령 예를들어서 아래의 정수로 이루어진 배열을 순서대로 정렬해본다고 가정해보자.\r\n\r\n\r\n```\r\n[2, 6, 1, 3, 7, 9]\r\n```\r\n\r\n프로그래밍으로 오름차순 정렬을 할 때, 여러 방법이 있을 것인데, 예를들어\r\n\r\n- 가장 작은 수 부터 찾아서 앞으로 보내기\r\n- 붙어있는 두개의 수를 비교하면서 앞으로 보내기\r\n- 역순으로 보내기\r\n\r\n등의 많은 방법이 있을것이다. 중요한 사실은 정렬의 모양은 굉장히 다양하다는 것이고, **상황마다 A방법이 빠를수도, B방법이 빠를수도** 있을 것이다.\r\n\r\n그런 **상황을 인지**하고, 어떤 상황에 **어떤 알고리즘이 가장 빠른지를 인지**하여 적용하는것이 핵심이다.\r\n\r\n### 기본적인 것\r\n- 버블 정렬\r\n- 선택 정렬\r\n- 삽입 정렬\r\n\r\n위의 대표적인 세가지 정렬은 실제에서는 꽤나 느리다고 알려져있어서, 자주 사용되지는 않는다고 한다. 그러나 핵심적인 개념을 담고 있기 때문에 배울 가치가 충분히 있다.\r\n\r\n> 참고 웹사이트\r\n&nbsp;\r\nhttps://www.toptal.com/developers/sorting-algorithms\r\n\r\n\r\n## 공부하고 나서\r\n---\r\n\r\n\r\n![이미지 설명](https://api.chamchipack.com/api/files/6chhfppu6fpcdiq/0p2vy0ofw4k1ni0/blob_RsyslVaynf.png)\r\n\r\n&nbsp;\r\n많은 정렬 알고리즘중 기초가 되는 3가지 것들은 사실 느리다. 그러나 이 세가지만 가지고 비교를 해본다면.\r\n\r\n- 거의 정렬된 상태라면 선택정렬이 매우 느리다 (앞에서부터 계속 비교를 하고 있음)\r\n- 삽입정렬은 지속적으로 데이터를 계속 정렬 할 경우 효과가 있다',
    markdown_title: '[알고리즘] 정렬 알고리즘',
    summary:
      '왜 배우는 것일까\r\n\r\n데이터를 정렬 시키는데에는 많은 방법들이 있다. 가령 예를들어서 아래의 정수로 이루어진 배열을 순서대로 정렬해본다고 가정해보자.\r\n\r\n\r\n\r\n\r\n프로그래밍으로 오름차순 ...',
    tag: [],
    theme: 'study',
    thumbnail:
      'https://api.chamchipack.com/api/files/6chhfppu6fpcdiq/0p2vy0ofw4k1ni0/blob_RsyslVaynf.png',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1734677344502,
    updated: 1734677344502,
    category: 'algorithm',
    imageId: [],
    log: 0,
    markdown_contents:
      '# 알고리즘\r\n## 바보도 모르는\r\n### 알곡리즘\r\n---\r\n',
    markdown_title: '우하하하하',
    summary: '알고리즘\r\n바보도 모르는\r\n알곡리즘',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: 'soyeon',
    userName: '영통퓨마',
    isPublic: true,
  },
  {
    created: 1734658391718,
    updated: 1734663177397,
    category: 'algorithm',
    imageId: [],
    log: 0,
    markdown_contents:
      '## 개념\r\n**특정 위치에 포인터나 값을 지정**하고, 조건에 따라 중간 혹은 시작지점부터 끝 지점까지 이동시키는 것\r\n\r\n배열, 문자열같은 선형 구조를 가지고 쓰이며, **특정 조건에 맞는 값들을 찾아**내는 개념. 일반적으로 한 쌍을 찾는다.\r\n\r\n### 방향\r\n- 배열이나 문자열의 양끝에서 시작하여 가운데에서 만나기\r\n- 맨 앞  즉, 0번과 1번 인덱스에서 각각 시작하기\r\n\r\n---\r\n\r\n## 예시\r\n\r\n- 정렬된 배열 중 더해서 0이 되는 두가지 숫자를 리턴하기\r\n- 일반적으로는 이중 반복문을 사용했지만 다중 포인터 방식을 사용해본다.\r\n```\r\nfunction sumZero(arr){\r\n    let left = 0;\r\n    let right = arr.length - 1;\r\n\r\n    while (left < right) {\r\n        let sum = arr[left] + arr[right];\r\n        if (sum === 0) {\r\n            return [arr[left], arr[right]];\r\n        } else if (sum > 0) {\r\n            right --;\r\n        } else {\r\n            left++;\r\n        }\r\n    }\r\n}\r\n\r\nconst result = sumZero([-4,-3,-2,-1,0,1,2,3,10])\r\n```\r\n\r\n---\r\n## 핵심\r\nleft와 right 변수와 같은것을 **포인터 변수**라고 지칭한다. 이것으로 기준점을 삼아놓는것이 중요하다. 그리고 **포인터 변수를 배열 혹은 문자열의 앞뒤로 이동시키면서** 값을 찾아낸다.\r\n\r\n---\r\n## 다음 예시\r\n\r\n- 정렬된 배열 중 각 숫자의 고유 갯수를 리턴하기\r\n- [1,2,3,3,3,4] 라면 고유한 숫자는 4개\r\n\r\n\r\n```\r\nfunction countUniqueValues(arr){\r\n    if (!arr.length) return 0\r\n    \r\n    let behind = 0;\r\n    let front = 1;\r\n    let result = 1\r\n\r\n    // 반복의 조건이 중요함\r\n    while (front < arr.length) {\r\n        if (arr[behind] !== arr[front]) {\r\n            result += 1\r\n        }\r\n        behind++;\r\n        front++;\r\n    }\r\n    return result\r\n}\r\n\r\nconst r = countUniqueValues([-2,-1,-1,0,1])\r\n```\r\n\r\n---\r\n## 파악한 점\r\n\r\n포인터 변수라는 **기준점을 명확하게 지정할 것**. 문제에 따라서 맨앞과 맨 뒤로 시작할지, 맨 앞에서 둘다 시작할지를 잘 생객해내야 함\r\n\r\n그리고 **반복의 조건도 잘 생각 해내야함**. 일반 for 문으로 반복 시켜도 되고, 조건 while문으로 반복시켜도 되는데, 조건이 명확해야 안에서의 계산 로직또한 명확해짐.\r\n\r\n### 삼중 이상의 포인터 변수 두기\r\n예를들어 아래의 문제가 있다고 가정해보자\r\n\r\n> const g = maxSubarraySum([2,6,9,2,1,8,5,6,3],3)\r\n&nbsp;\r\n두번째 파라미터만큼의 간격으로 배열의 요소들을 더해서 가장 큰숫자를 리턴하기\r\n\r\n포인터 변수를 3개를 두고 해도 된다. 아래의 주석부분과 주석 아닌 부분을 비교해보자. 포인터변수를 3개 둔것과, 미리 앞을 계산 해두고 앞 뒤만 잘라서 계산을 한다. 마치 포인터변수를 반복문 안에서 선언하고 쓰는것 같다. \r\n\r\n계산방식이 여러 방향이 있기때문에, 항상 비교를 하면서 공부해 나가면 더욱 도움이 된다.\r\n\r\n\r\n```\r\nfunction maxSubarraySum(arr, num){\r\n    let max = 0;\r\n    let temp = 0;\r\n\r\n    // let first = 0;\r\n    // let second = first + 1;\r\n    // let third = second + 1;\r\n\r\n    // for (let i = first; third + 1 < arr.length; i++) {\r\n    //     temp = arr[i] + arr[second] + arr[third]\r\n    //     max = Math.max(max, temp)\r\n\r\n    //     second++;\r\n    //     third++;\r\n    // }\r\n\r\n    for (let i = 0; i < num; i++) {\r\n        temp += arr[i]\r\n    }\r\n    max = temp\r\n\r\n    for (let i = num; i < arr.length; i++) {\r\n        temp = temp + arr[i] - arr[i - num]\r\n        max = Math.max(max, temp)\r\n    }\r\n    return max\r\n}\r\n```\r\n\r\n',
    markdown_title: '[알고리즘] 다중 포인터',
    summary:
      '개념\r\n특정 위치에 포인터나 값을 지정하고, 조건에 따라 중간 혹은 시작지점부터 끝 지점까지 이동시키는 것\r\n\r\n배열, 문자열같은 선형 구조를 가지고 쓰이며, 특정 조건에 맞는 값들을 ...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1734573723556,
    updated: 1734598037423,
    category: 'algorithm',
    imageId: [],
    log: 0,
    markdown_contents:
      '### 사용하는 경우\r\n---\r\n데이터 내에서 중복이나 패턴을 효율적으로 파악해야 할 때 주로 사용.\r\n\r\n- 빈도 기반 비교를 해야 할 때:\r\n예를 들어, 두 문자열이 아나그램 관계인지(같은 문자 빈도를 가지는지), 두 배열이 같은 멤버십(multiset)을 이루는지 판단할 때.\r\n\r\n- 데이터 내 **중복이나 특정 값의 존재 여부**를 빠르게 파악할 때:\r\n예를 들어, 배열 내 어떤 값이 2회 이상 등장하는지 확인하거나, 어떤 키워드가 문서 내 몇 번 등장하는지 세는 경우.\r\n\r\n- 최빈값(Mode) 찾기:\r\n데이터에서 **가장 많이 등장하는 값**이 무엇인지 파악해야 할 때.\r\n\r\n- 수량, 비율 등 분포 특성을 분석할 때:\r\n문자열, 배열, 리스트 등에 존재하는 요소들의 분포(각 값이 몇 번 등장하는지)를 한 번의 순회로 쉽게 계산할 수 있어, 이후 추가적인 정렬, 비교, 필터링 로직에서 활용할 수 있음.\r\n\r\n정리하자면, 빈도수 카운팅은 원소별 등장 횟수를 파악해야 하는 문제에서 강력하고 효율적인 도구이다\r\n\r\n&nbsp;\r\n\r\n---\r\n\r\n### 문제 및 조건\r\n> [1] 정수인 배열A와 B를 비교하여 A의 각 값의 제곱값이 B에 들어있는지 확인하기.\r\n&nbsp;\r\n[2] B의 순서는 상관없다\r\n&nbsp;\r\n[3] A의 개수만큼 B에 들어있어야 한다.\r\n\r\n\r\n```\r\nfunction same(arr1, arr2){\r\n    if(arr1.length !== arr2.length){\r\n        return false;\r\n    }\r\n    let frequencyCounter1 = {}\r\n    let frequencyCounter2 = {}\r\n    for(let val of arr1){\r\n        frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1\r\n    }\r\n    for(let val of arr2){\r\n        frequencyCounter2[val] = (frequencyCounter2[val] || 0) + 1        \r\n    }\r\n    console.log(frequencyCounter1);\r\n    console.log(frequencyCounter2);\r\n    for(let key in frequencyCounter1){\r\n        if(!(key ** 2 in frequencyCounter2)){\r\n            return false\r\n        }\r\n        if(frequencyCounter2[key ** 2] !== frequencyCounter1[key]){\r\n            return false\r\n        }\r\n    }\r\n    return true\r\n}\r\n\r\nsame([1,2,3,2,5], [9,1,4,4,11])\r\n```\r\n\r\n---\r\n# [내가 찾은 핵심]\r\n\r\n**먼저 각 배열에서 각 데이터의 빈도수가 얼마나 되는지 카운트 하기**\r\n\r\n```\r\nfor(let val of arr1){\r\n        frequencyCounter1[val] = (frequencyCounter1[val] || 0) + 1\r\n    }\r\n```\r\n간단하게 빈도수를 체크해준다. 중복 없으면 1을, 있으면 +1를 증가하여 객체로 만든다.\r\n\r\n&nbsp;\r\n\r\n**계산된 빈도 수에 따라서 서로의 값을 비교하기**\r\n\r\n```\r\nif(!(key ** 2 in frequencyCounter2)){\r\n            return false\r\n}\r\n\r\nif(frequencyCounter2[key ** 2] !== frequencyCounter1[key]){\r\n            return false\r\n}\r\n```\r\n비교 객체에 찾고자하는 값이 없으면 false 처리를 해준다. 그리고 찾고자하는 값과 그 값의 처음 빈도수를 비교하여 처리한다.\r\n\r\n### 예외처리의 중요성\r\n올바르게 값을 찾는 알고리즘이라고 가정해도, 다른 자료형의 값이 들어온다던지, 예상치 못한 값의 침입은 항상 대비를 해야할것이다. 위의 예시에서와 마찬가지로 타입 방어를 강화해서 예외처리를 해야할 것이 중요하다. length가 맞는지 등등의 상황을 항상 고려해야 한다.\r\n\r\n---\r\n\r\n## 배운점\r\n\r\n빈도 수를 카운트 하는건 어렵지 않은것 같다. 이 말은 빈도 수를 제대로 카운트 해 놓으면 뒤의 작업은 비교만 하면 쉽게 처리할 수 있다는 뜻으로 생각이 된다. 5개 정도의 같은 유형 풀이를 생각해 보았을때, 오히려 **값을 비교하여 정답을 도출해 낼때 오류가 생기는 경우가 있다.**\r\n\r\n명확하게 방향(빈도수를 체크하기)을 잡고 **값을 비교하는것은 더욱 정확하게 하는** 스킬이 요구되는 바 이다.\r\n\r\n### 추가로 알 게 된것 \r\n- 두개이상의 배열의 계산 중...\r\n\r\nA와 B를 각각 독립적으로 반복(iteration)하는 경우:\r\n예를 들어, A를 한 번 순회하고 (O(N)), 이후 B를 한 번 순회하는 (O(N)) 과정을 독립적으로 수행한다고 가정하면 전체 복잡도는 O(N) + O(N) = O(2N) ≈ O(N)이다\r\n\r\nA의 각 원소에 대해 B를 다시 내부 루프로 순회하는 경우:\r\n여기서는 A를 한 번 순회하면서 (O(N)) 매 A의 원소마다 B를 전부 탐색한다고 했을 때 (O(N)), 총 시간 복잡도는 O(N) * O(N) = O(N²) 이다\r\n\r\n결국, 동일한 작업이라 가정했을 때, 독립적으로 각각의 배열을 순회하는 방법이 O(N)으로 더 효율적이며, 중첩 루프 방식은 O(N²)으로 크기가 커질수록 비효율적이다',
    markdown_title: '[알고리즘] 빈도 수 카운터',
    summary:
      '사용하는 경우\r\n\r\n데이터 내에서 중복이나 패턴을 효율적으로 파악해야 할 때 주로 사용.\r\n빈도 기반 비교를 해야 할 때:\r\n예를 들어, 두 문자열이 아나그램 관계인지(같은 문자 빈도를 ...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1734490688472,
    updated: 1734520468283,
    category: '',
    imageId: [],
    log: 0,
    markdown_contents:
      '## 일반 질문\r\n---\r\n- 어떤것을 더 공부해야할까?\r\n> IoT 회사 -> 프론트엔드, 도커, 쿠버네티스, \r\n\r\n&nbsp;\r\n\r\n- 개인프로젝트 한것의 발전방향과 어필 하는 방법\r\n- 개인 깃허브로 어필하는방법 \r\n- 알고리즘 공부의 접근법\r\n\r\n&nbsp;\r\n\r\n## 포트폴리오 질문\r\n---\r\n- 간단 자기소개 부분 적을때 양식\r\n> 3년 차 개발자로서, 프론트엔드로 경력을 시작했지만 백엔드 프로젝트에도 적극적으로 참여하여 개발한 경험을 가지고 있습니다. 주로 리눅스를 통한 Next.js와 Nuxt.js를 활용하여 프론트엔드 개발에 강점을 가지고 있으며, 이를 통해 다양한 웹 애플리케이션을 성공적으로 개발해왔습니다. \r\n&nbsp;\r\n프론트엔드뿐만 아니라, 홈서버 설치와 같은 인프라 작업을 통해 프로젝트 구조를 설계하고 구축하는 경험또한 가지고 있습니다. 프론트, 백엔드, 서버 개발을 넘나들며 아키텍처 설계부터 개발등 다양한 기술을 학습 및 사용하며 시스템의 전체적인 구조를 이해하기위해 노력하고 있습니다.\r\n\r\n- 적혀져있는것 말고도 관련된 잡다한것도 많았는데, 적는게 유리할지\r\n- 채용자 입장에서 포트폴리오중 먼저 보는것.\r\n- 성과를 다이나믹하게 수치화할 수 있는 부분이 잘 보이지 않습니다. 어떻게 포트폴리오를 작성해야할까요?\r\n\r\n### 사진은 완벽한거 아니면 패스 시켜라\r\n\r\n## 답변 \r\n---\r\n\r\n회사에서 듣고싶으하는 말 -> 그 사람들의 생각을 읽어야 한다. 원리에 대한 이해\r\n\r\n- 즉시 업무를 처리할 수 있는사람\r\n- 즉시 수행하기위한 역량을 가진사람\r\n\r\n-> 채용공고에서 내가 가지고있지 않은 자격을 추가할 수 있또록\r\n\r\n### 명심해야할 점\r\n---\r\n- 답정너이론\r\n> 회사에서 뽑고자 하는 인재상에 맞게 작성하는게 핵심.\r\n&nbsp;\r\n백엔드 뽑는데 프론트엔드 항목 넣지 말아라\r\n\r\n- 다다익선의 역설\r\n> 애매한 프로젝트 5개 보다 깊게 경험한 프로젝트 1개가 좋다\r\nhtml css 얘기하는 사람과 react lifecycle 얘기하는 사람은 당연히 다르다\r\n&nbsp;\r\n불필요한 내용 과감히 삭제.\r\n\r\n- 추상어의 저주\r\n\r\n> 추상적인것을 깊이감을 넣어서 작성\r\n&nbsp;\r\n구체성 (디테일하게 얘기) 으로 신뢰성을 주자\r\n구체성을 높여야 신뢰성을 높이고 면접에서 보고싶어할것이다.\r\n\r\n- 차별성\r\n> 추상적인것을 구체적으로 적으면 차별성이 생긴다.\r\n수치 불가능시\r\n문제점 해결책 성과 / 배운점 /깨달은 점의 구조로 작성해라 (배경, 이유, 성과)\r\n이렇게 적음으로써 공부할수밖에 없는 구조가 만들어진다. \r\n\r\n### 단순 기능 개발하는 (1단걔) 개발자가 아닌 2~4단계의 고 수준의 개발자로 보이게끔 작성해야한다.\r\n\r\n포트폴리오를 보면서 "그래도 개발을 해봤네" 라는 느낌이 들게끔\r\n\r\n- 프론트엔드 개발자면 프론트엔드만 쓸것\r\n- 쿠버네티스 같은 애매한것은 빼도 된다.\r\n- 컴포넌트 재사용 최적화? 얼마나 디테일하게 했느냐 (구체성 추가 -> 신뢰성 증가)\r\n- 업뮤효율성 증가? -> 어떻게? \r\n\r\n남들이 사용할만한 단어를 사용하면 그 사람을 판단할 수 없다. 니가 누군지 판단할 수 있또록 글을 써야한다. \r\n\r\n사진을 붙였다 => UI를 진짜 어필할거면 사진을 제대로 붙이는게 나을거면, 그냥 빼버리던가. \r\n\r\n뭐든 쓸거면 디테일하게 작성해라\r\n\r\n짧다고 능사가 아니다. 네가 개발 잘하는지를 드러내는게 핵심이다. \r\n\r\n완벽하게 셋업된 하나를 만들고\r\n\r\n## 공부\r\n여러회사의 리스트업 -> 우대사항을 따로 정리해라. 공통적으로 얘기하는 요소를 공략 및 공부\r\n\r\n## 전형절차\r\n코테 없으면 코딩 준비하지마. 이것은 전략적으로 선택해라\r\n\r\n시험 통과용으로만 공부해라 \r\n\r\n## 알고리즘 공부 \r\n1. 문제풀기\r\n2. 맞히던 틀리던 타인의 풀이와 무조건 비교하라\r\n3. 타인의 풀이를 보고 왜 그렇게 풀었는지, 어떻게 생각해 낸건지를 고민해라\r\n## 분석해라\r\n4. 문제 다시풀기 (내방식 아니라 타인의 풀이 방식을 가지고 풀기)\r\n5. 한 유형만 풀어라. 한가지 개념을 확실히 가지고 가라\r\n\r\n### 꾸준함과 피드백을 받으려고 하는 용기',
    markdown_title: '자소서 첨삭 질문 모음',
    summary: '일반 질문\r\n어떤것을 더 공부해야할까?',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1733755120485,
    updated: 1737787832271,
    category: 'infra',
    imageId: [],
    log: 0,
    markdown_contents:
      "## 웹팩 개념\r\n- 조립 공장과 같은 개념 : 코드 조각들을 모아서 하나의 파일을 만들어주는 역할\r\n\r\n## 필요성\r\n- 웹사이트 만들때 JS, css, 기타 여러파일들이 필요하다.\r\n- 파일들이 따로 흩어져있으면 만들기 어렵고 느려질 수 있다. 특히 js 파일은 다 읽어오는데 시간이 걸린다.\r\n- 웹팩이 파일들을 합쳐서 하나의 파일로 만들어준다.\r\n\r\n## 기본 역할\r\n- 번들링 : 여러개의 파일을 하나로 묶어주는것을 의미함.\r\n- 컴파일 : 타입스크립트 같은 새로운 코드들을 변환 해서 브라우저에서 돌아가게끔 함\r\n\r\n#### 기본 로직 ####\r\n- js, ts, css 파일 등 여러가지 파일을 하나로 묶어서 bundle.js 와 같은 하나의 큰 파일로 만든다 => 이것을 html 파일과 연결해서 웹 페이지를 띄운다.\r\n- 여러개의 파일을 하나로 로드할 수 있어서 빠르고 효율적이다.\r\n\r\n\r\n## 번들링\r\n- 개념 : 여러파일 (js, css, image 등)을 하나의 파일 또는 적은수의 파일로 묶는과정\r\n ### 과정\r\n- 번들링의 시작점을 지정한다. 이를 엔트리 포인트라고 한다.\r\n- 엔트리 포인트의 js 파일부터 의존성을 따라가며 파일을 모은다. \r\n- index.js가 utils.js를 가져오고, 다른파일 의존성있으면 계속 가져와서 수집\r\n- 웹팩은 기본적으로 js 파일만 이해가능. css, image 파일등을 이해하기 위해서 css-loader, style-loader 등을 사용해서 번들링에 포함시킴\r\n\r\n```\r\n// webpack.config.js 예시\r\n\r\nmodule.exports = {\r\n  mode: 'production', // 여기서 'development'나 'production'을 설정 가능\r\n  entry: './src/index.js',\r\n  output: {\r\n    filename: 'bundle.js',\r\n    path: path.resolve(__dirname, 'dist'),\r\n  },\r\n  module: {\r\n    rules: [\r\n      {\r\n        test: /\\.css$/,\r\n        use: ['style-loader', 'css-loader'],\r\n      },\r\n    ],\r\n  },\r\n}\r\n```\r\n\r\n\r\n## 컴파일\r\n### 개념 : \r\n- 작성한 코드를 컴퓨터가 이해할 수 있는 언어로 변환하는 과정\r\n- 최신 자바스크립트나 타입스크립트 같은 코드를 변환해서 모든 브라우저에서 이해할 수 있는 일반적인 자바스크립트로 바꿔주는 일\r\n- ES6+ 문법을 사용했을 때, 옛날 브라우저에서는 이 기능들을 이해하지 못해. 그래서 웹팩은 이 코드를 Babel 같은 도구와 함께 사용해서 옛날 브라우저도 이해할 수 있게 변환\r\n\r\n# 컴파일러와 인터프리터\r\n- 컴파일러 : 프로그램 전체를 한 번에 기계어로 변환해서 실행 파일을 만들\r\n- 인터프리터 : 소스 코드를 한 줄씩 읽어서 바로 실행해. 파이썬이나 자바스크립트는 인터프리터 언어\r\n\r\n\r\n## 과정\r\n- 소스 코드 입력: 우리가 작성한 소스 코드가 컴파일러에게 전달돼.\r\n\r\n- 어휘 분석(Lexical Analysis): 컴파일러가 소스 코드를 단어 단위로 쪼개고 의미를 파악해. 이를 **토큰(Token)**이라고 해. 예를 들어, 변수 이름, 숫자, 연산자 등을 각각의 토큰으로 나누어 분석함.\r\n\r\n- 구문 분석(Syntax Analysis): 컴파일러는 코드가 언어의 문법에 맞게 작성됐는지 확인해. 이 과정에서 문법 오류가 발견되면, 컴파일이 멈추고 오류 메시지를 보여줌.\r\n\r\n- 중간 코드 생성: 코드를 중간 단계의 표현으로 변환해. 이 중간 코드는 기계어와 고급 언어 사이의 중간 단계로, 여러 최적화 작업이 적용될 수 있음.\r\n\r\n- 최적화(Optimization): 중간 코드를 좀 더 효율적으로 만들어. 예를 들어, 불필요한 계산을 줄이거나, 반복되는 코드를 최적화해서 프로그램의 실행 속도를 높임.\r\n\r\n- 기계어 생성: 최종적으로 기계어 코드로 변환해. 이 단계에서 실행 파일이 생성되는데, 이 파일은 컴퓨터가 직접 실행할 수 있는 형태임.\r\n\r\n\r\n## 바벨\r\n- 자바스크립트 트랜스파일러 : 바벨은 최신 자바스크립트 코드를 옛날 브라우저에서도 이해할 수 있도록 변환해주는 역할",
    markdown_title: '나름대로 정리해본 웹팩',
    summary:
      '웹팩 개념\r\n조립 공장과 같은 개념 : 코드 조각들을 모아서 하나의 파일을 만들어주는 역할\r\n\r\n필요성\r\n웹사이트 만들때 JS, css, 기타 여러파일들이 필요하다.\r\n파일들이 따로 흩...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1733754693447,
    updated: 1737787821387,
    category: 'infra',
    imageId: [],
    log: 0,
    markdown_contents:
      '## 쿠버네티스 가상환경 \r\n---\r\n### minikube 가상환경으로 접속\r\n\r\n```\r\neval $(minikube docker-env)\r\n```\r\n현재 쉘 환경에 Minikube VM 내부의 Docker 데몬 환경을 설정한다. \r\n\r\n즉, **Minikube VM 내부의 Docker 데몬에 접속한다**\r\n\r\n### 빌드 및 이미지 생성\r\n\r\n```\r\ndocker build -t 이미지명:태그명 .\r\n\r\n모노레포시에는 패키지 루트에서 ./packages/프로젝트디렉토리/Dockerfile .\r\n```\r\n#\r\n\r\n## Helm 작성\r\n---\r\n### Helm 차트 생성 혹은 수정\r\n차트는 하나의 프로젝트 (어플리케이션) 이라고 생각하면 쉽다\r\n\r\n\r\n```\r\nhelm create [이미지 이름 (=차트 이름)]\r\n\r\n나는 일반적으로 이미지 명으로 작성한다\r\n```\r\n그리고 해당 차트의 디렉토리로 가서 value.yaml 파일을 수정을 한다 \r\n\r\n이미지명과 태그명을 정확하게 입력한다. \r\n\r\n### install 혹은 upgrade\r\n\r\n```\r\nhelm install [릴리즈명] [차트명] (이미지명)\r\n\r\nhelm upgrade [your-release-name] [your-chart-name]\r\n```\r\n\r\n### 차트 삭제\r\n```\r\nhelm uninstall [릴리즈명]\r\n```\r\n\r\n### 이전버전으로 롤백하기\r\n```\r\nhelm history 릴리즈명\r\n\r\nhelm rollback 릴리즈명 [REVISION]\r\n```\r\nRevision은 해당 히스토리를 보면 숫자로 되어있다. 그것을 넣으면 해당 버전으로 롤백된다.',
    markdown_title: '배포 시나리오 정리',
    summary:
      '쿠버네티스 가상환경 \r\n\r\nminikube 가상환경으로 접속\r\n\r\n\r\n현재 쉘 환경에 Minikube VM 내부의 Docker 데몬 환경을 설정한다. \r\n\r\n즉, Minikube ...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1733230026697,
    updated: 1737738166075,
    category: 'japanese',
    imageId: [],
    log: 0,
    markdown_contents:
      '## 風の強さがちょっと\r\n\r\n- 風(caze) 바람 \r\n- 強さ (tsuyosa) 강함, 강함의 정도\r\n## 心を揺さぶりすぎて\r\n- 心 (kokoro) 마음\r\n- 揺さぶり (yusaburi) 흔들림\r\n- すぎる (sugite) 너무 ~하다 (조동사)\r\n\r\n## 真面目に見つめた 君が恋しい\r\n\r\n- 真面目だ (majimeda) 진정으로, 성실히\r\n- 見つめる (mitsumeru) 응시하다, 바라보다\r\n- 恋しい (koishii) 그리워하다\r\n\r\n## でんぐり返しの日々\r\n- でんぐり返し (kae) 공중제비, 뒤집어지기\r\n- 日々 (hibi) 날들, 매일\r\n\r\n## 可哀想なふりをして\r\n- 可哀想だ(kawaisouda) 불쌍하다, 가엾다\r\n- ふり ~인척 (= 불쌍한척)\r\n\r\n## だらけてみたけど\r\n- だらけて 느슨해지다, 게으름피다\r\n- みた ~해보다\r\n\r\n## 希望の光は目の前でずっと輝いている 幸せだ\r\n\r\n- 希望 (きぼう) 희망\r\n- 目の前で 눈 앞에\r\n- ずっと 줄곧, 계속\r\n- 輝く (kagayaku) 빛나다\r\n- 幸せだ (しあわせ) 행복하다\r\n\r\n## 麦わらの帽子の君が\r\n- 麦わらの帽子 (mugi, ぼうし) 밀짚모자\r\n\r\n## 揺れたマリーゴールドに似てる\r\n- 揺れる (yureru) 흔들리다 \r\n\r\n- 명사+に+似る (niru) 명사~와 닮다\r\n## あれは 空がまだ青い夏のこと\r\n- 夏 (natsu) 여름\r\n\r\n- 空 (sora) 하늘\r\n\r\n## 懐かしいと笑えたあの日の恋\r\n- 懐かしい (natsukashii) 그립다, 아련하다\r\n\r\n## 「もう離れないで」と\r\n- もう: 이제, 더 이상 (부사)\r\n- 離れる (hanareru) (붙은것이) 떨어지다, 사이가 멀어지다 2그룹\r\n- で: ~하지 말아라\r\n- と: ~라고\r\n## 泣きそうな目で見つめる君を\r\n\r\n- 泣く(naku) 울다\r\n- 泣きそう: "울 것 같다"로, 동사 기본형 + そう는 추측이나 상태를 나타냄, な: 형용사화\r\n\r\n## 雲のような優しさでそっとぎゅっと\r\n- 雲 (くも) 구름\r\n- のような: ~와 같은, 명사 + のような: 명사를 비유하거나 유사성\r\n- 優しい (yasashii) 優しさ 형용사 + さ => 명사화, 부드러움 상냥함\r\n- そっと: 살며시, 조용히\r\n- ぎゅっと: 꽉, 단단히\r\n\r\n##  抱きしめて 抱きしめて 離さない\r\n- 抱きしめる (dakishimeru) 끌어안다\r\n- 抱く（だく）: 안다 + しめる: 강하게 하다 → "꽉 안다."\r\n\r\n- 離す (hanasu) (밀착한것) 풀다, 놓다, 떼다, 거리를 벌리다\r\n\r\n--- \r\n\r\n## 本当の気持ち全部\r\n- 本当(ほんとう): 진짜, 진실\r\n- 気持ち(きもち): 마음, 감정\r\n\r\n## 吐き出せるほど強くはない\r\n- 吐き出せる(はきだせる) : 토해낼 수 있다, 내뱉을 수 있다 => 마음속의 것을 내뱉는다\r\n- ほど: ~할 정도로", "만큼"이라는 뜻 (좀더 공식적, 극단적)\r\n\r\n=> 내 뱉을 수 있는 정도 라는 뜻\r\n\r\n- 強くはない : 강하지 않다\r\n\r\n## でも不思議なくらいに\r\n- 不思議(ふしぎ) : 이상함, 신기함\r\n- くらいに : 정도로, ~ 할만큼 (좀더 가벼운의미)\r\n\r\n## 絶望は見えない\r\n- 絶望(ぜつぼう): 절망\r\n- 見えない : 見える(보이다)\r\n\r\n## 目の奥にずっと写るシルエット大好きさ\r\n- 奥(おく) : 깊은곳, 안쪽\r\n- 写る(うつる): 비치다, 반사되다\r\n- さ : 문장 끝에 붙어 가벼운 강조나 친근감을 표현\r\n\r\n## 柔らかな肌を寄せあい\r\n- 柔らかい : 부드러운, 포근한\r\n- 肌(はだ) : 피부, 살결\r\n- 寄せ合う(よせあう) : 가까이 맞대다, い는 연결형\r\n\r\n## 少し冷たい空気を2人\r\n- 冷たい(つめたい) : 차가운\r\n- 空気(くうき) : 공기\r\n\r\n ## かみしめて歩く今日という日に 何と\r\n- 噛みしめる(かみしめる) : 곱씹다, 음미하다\r\n- 歩く(あるく): 걷다\r\n- ~という: ~ 이라는\r\n\r\n## 名前をつけようかなんて話して\r\n- つける(붙이다) : つけようか 의향형 つけよう에 의문형 か가 결합.\r\n-  의향형 : ~ 할까 라는 의미, 1그룹 어미에서 ouka, 2그룹: youka\r\n- なんて : ~ 같은, 감탄사\r\n\r\n## ああ アイラブユーの言葉じゃ\r\n- 言葉(ことば): 말, 단어\r\n- じゃ: では\r\n\r\n## 足りないからとキスして\r\n- 足りない(たりない): 부족하다\r\n\r\n## 雲がまだ2人の影を残すから\r\n- 影(かげ): 그림자\r\n- 残す(のこす): 남기다\r\n\r\n## いつまでも いつまでも このまま\r\n- いつまでも: 언제까지나, 영원히\r\n- このまま: 이 상태 그대로\r\n\r\n\r\n',
    markdown_title: 'マリゴルド　あいみょん',
    summary:
      '風の強さがちょっと\r\n風(caze) 바람 \r\n強さ (tsuyosa) 강함, 강함의 정도\r\n心を揺さぶりすぎて\r\n心 (kokoro) 마음\r\n揺さぶり (yusaburi) 흔들림\r\nすぎる (sugit...',
    tag: [],
    theme: 'general',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1732584172453,
    updated: 1737738156015,
    category: 'trip',
    imageId: [],
    log: 0,
    markdown_contents:
      '성우와 함께하는 후쿠오카 여행 일정을 정리합니다. 앞으로 이걸 참고해서 여행을 다녀볼거에요\r\n\r\n\r\n## 1일차\r\n\r\n---\r\n\r\n- **08시** 광주에서 출발\r\n- **11시** 김해공항 도착\r\n- **13시** 비행기 탑승\r\n- 입국심사 종료후 히타로 가는 버스 탑승하기\r\n\r\n\r\n### 공항에서 히타가는 버스 타는법\r\n\r\n> 국내선 순환 셔틀버스로 이동 후\r\n국내선 공항 터미널로 이동하기,\r\nG게이트까지 이동, 17 고속버스로 가기\r\n\r\n저녁 : 소후렌\r\n\r\n![이미지 설명](https://api.chamchipack.com/api/files/6chhfppu6fpcdiq/7zbdcuk3a51uj68/blob_FNyzRm5Gzj.png)\r\n\r\n마메다마치 거리 산책\r\n\r\n![이미지 설명](https://api.chamchipack.com/api/files/6chhfppu6fpcdiq/cogzlg81t0w213p/blob_Qpk5ssPc20.png)\r\n\r\n---\r\n\r\n## 2일차\r\n\r\n- 10시 체크아웃\r\n- 11시 장어덮밥 히타마부시 센야\r\n- 13시 하카타 출발\r\n\r\n> 하카타 센넨몬(천년문)\r\n하카타역 옥상정원\r\n\r\n\r\n- 15시 체크인\r\n- 16시 부터 텐진 이동\r\n\r\n---\r\n\r\n## 3일차\r\n\r\n나눠서 기록합니다\r\n\r\n### 오전일정\r\n- 라쿠스이엔 찻집체험\r\n- 스미요시신사\r\n- 우동 하가쿠레 우동\r\n\r\n### 여기부터는 기타큐슈\r\n- 고쿠라성 \r\n\r\n![이미지 설명](https://api.chamchipack.com/api/files/6chhfppu6fpcdiq/xwhh3zi6hxnhwm5/blob_IvWeq5zmVN.png)\r\n\r\n- 고쿠라역 야끼카레 및 \r\n- 모지코항\r\n- 모지코 레트로 전망대\r\n- 간몬 해협\r\n\r\n![이미지 설명](https://api.chamchipack.com/api/files/6chhfppu6fpcdiq/qs5easwxooev26k/blob_xXwyo8zBAe.png)\r\n\r\n- 하카탄사카나야고로 (스푸파)\r\n- 나카스강\r\n- 로바타 산코바시 (이자카야)\r\n- \r\n\r\n\r\n![이미지 설명](https://api.chamchipack.com/api/files/6chhfppu6fpcdiq/8gl51v50hgmjqko/blob_3kfl5PrQx0.png)',
    markdown_title: '11.29 - 12.02 후쿠오카여행',
    summary:
      '성우와 함께하는 후쿠오카 여행 일정을 정리합니다. 앞으로 이걸 참고해서 여행을 다녀볼거에요\r\n\r\n\r\n1일차\r\n08시 광주에서 출발\r\n11시 김해공항 도착\r\n13시 비행기 탑승\r\n입국심사 ...',
    tag: [],
    theme: 'general',
    thumbnail:
      'https://api.chamchipack.com/api/files/6chhfppu6fpcdiq/7zbdcuk3a51uj68/blob_FNyzRm5Gzj.png',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1731838959038,
    updated: 1731838959038,
    category: '',
    imageId: [],
    log: 0,
    markdown_contents:
      '---\r\n\r\n\r\n### 도입배경\r\n\r\n컴포넌트 단위 개발을 세부적으로 쪼개는 도중, 코드가 지저분해지고 **유지보수에 어려움**이 생겼다. 라이브러리를 통해 불필요한 코드를 줄이고 기능 개선을 위해 React Query를 본격적으로 도입을 고민한다.\r\n\r\n- 코드 정리\r\n- 유지보수 편의성 높이기\r\n\r\n### 고민\r\n\r\nReact Query를 전역에서 사용할 모듈로 만들자니, API 호출시 파라미터가 서로 다른문제가 있고, 타입의 안전성 확보 등으로 인해 전역으로 만드는게 제약이 생기는 경우가 있다.\r\n\r\n 반대로 컴포넌트단위로 만들자니 오히려 유지보수 거리가 늘어날 수 있다는 생각도 들었다.\r\n\r\n또한 기존 API 체재를 뒤집어야하는 불편함도 감수해야한다. 그러나 이는 기능개선을 위해서는 필수인 과정이기 때문에 고민할 필요는 없었다.\r\n\r\n### 결론\r\n\r\n- 전역이 아닌 1차적으로 컴포넌트 단위에 적용해보기\r\n- 1개 기능에만 react Query를 이용해 변경해 보기\r\n',
    markdown_title: 'React Query 도입에 관한 고찰',
    summary:
      '도입배경\r\n\r\n컴포넌트 단위 개발을 세부적으로 쪼개는 도중, 코드가 지저분해지고 유지보수에 어려움이 생겼다. 라이브러리를 통해 불필요한 코드를 줄이고 기능 개선을 위해 React Qu...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1731252860544,
    updated: 1732363179644,
    category: '',
    imageId: [],
    log: 0,
    markdown_contents:
      '### [11월 08일]\r\n---\r\n\r\n- 단어장 생성 로직 추가\r\n- 세션으로 로그인 필요한 페이지 예외처리\r\n\r\n\r\n\r\n### [11월 10일]\r\n---\r\n\r\n- 형용사 기본 틀 제작\r\n- 단어장 수정 및 삭제 로직 추가\r\n\r\n\r\n### [11월 11일]\r\n\r\n---\r\n\r\n- 형용사 변화형 만들기\r\n- 단어장에서 내가 외운 단어 표시하기 로직\r\n- 단어장 수정할때 단어장 이름 바꾸게 하기\r\n\r\n### [11월 12일]\r\n---\r\n\r\n- 야, 유, 요 로직 수정\r\n\r\n### [11월 21일]\r\n---\r\n\r\n- 단어 키에 주석키 달기 desc\r\n- 단어 등록 및 수정 완료\r\n\r\n\r\n### [11월 22일]\r\n---\r\n\r\n- 단어 목록에서 뒤로가기시 페이지네이션 유지\r\n- 참고주석 인풋에서 정규식 해제',
    markdown_title: '단어장 개발일지',
    summary:
      '[11월 08일]\r\n단어장 생성 로직 추가\r\n세션으로 로그인 필요한 페이지 예외처리\r\n\r\n\r\n\r\n[11월 10일]\r\n형용사 기본 틀 제작\r\n단어장 수정 및 삭제 로직 추가\r\n\r\n\r\n[11월 11일]\r\n...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
  {
    created: 1729649688639,
    updated: 1737787790636,
    category: 'infra',
    imageId: [],
    log: 0,
    markdown_contents:
      '## 설치\r\n\r\n**curl -sfL https://get.k3s.io | sudo sh -**\r\n\r\n가져오고\r\n\r\n**sudo systemctl status k3s**\r\n\r\n확인하고\r\n\r\n**export KUBECONFIG=/etc/rancher/k3s/k3s.yaml**\r\n\r\n환경변수\r\n\r\n**sudo chmod 644 /etc/rancher/k3s/k3s.yaml**\r\n\r\n권한 주던가\r\n\r\n**kubectl get nodes**\r\n\r\n노드 도는거 확인하기\r\n\r\n---\r\n\r\n## 파드 관련\r\n\r\ndocker save -o 원하는파일명.tar 이미지명:latest (이미지를 tar화)\r\n\r\nsudo k3s ctr images import 원하는파일명.tar (파일을 쿠버로 입력)\r\n\r\n\r\n1. deployment.yaml 및 service.yaml 작성\r\n\r\n2. kubectl apply -f deployment.yaml // service.yaml\r\n\r\n### 확인 명령어\r\n\r\nkubectl get pods\r\n\r\nkubectl get svc (서비스 확인용)\r\n\r\n### 파드 서비스 삭제\r\n\r\nkubectl delete svc <서비스명>\r\n\r\nkubectl delete deployment <파드>\r\n\r\n### 파드 서비스 올리기\r\n\r\nkubectl apply -f service.yaml\r\n\r\nkubectl apply -f deployment.yaml\r\nddd\r\n\r\n### 미니쿠버는 어떻게?\r\n\r\nminikube status (확인)\r\n\r\nkubectl config get-contexts (쿠버 컨피그 확인)\r\n\r\n> K3S가 설치되어있다는 전제하에 \r\nunset KUBECONFIG (K3S 컨피그 해제)\r\nexport KUBECONFIG=/etc/rancher/k3s/k3s.yaml (K3S 컨피그 적용)\r\n\r\n\r\n---\r\n## 순서대로 \r\n\r\ndocker build -t blog-chamchi:[태그부분] -f /home/chanik/mono/pnpm/chamchi_pnpm_mono./packages/blog/Dockerfile .\r\n\r\nkubectl delete svc\r\nkubectl delete deployment\r\n\r\ndocker save -o 원하는파일명.tar blog-chamchi:[태그부분]\r\n\r\nsudo k3s ctr images import 원하는파일명.tar\r\n\r\nkubectl apply -f service.yaml\r\n\r\nkubectl apply -f deployment.yaml\r\n\r\nkubectl get pods\r\n\r\nkubectl get svc ',
    markdown_title: 'K3S 시작하기',
    summary:
      '설치\r\n\r\ncurl -sfL https://get.k3s.io | sudo sh -\r\n\r\n가져오고\r\n\r\nsudo systemctl status k3s\r\n\r\n확인하고\r\n\r\nexpor...',
    tag: [],
    theme: 'study',
    thumbnail: '',
    userId: '시스템관리자',
    userName: '시스템관리자',
    isPublic: true,
  },
];
